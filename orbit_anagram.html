<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8">

	<title>Galaktisches Etymologieforschungsinstitut</title>


	<style>	
		body{
			background-color: black;
			width: 100%;
			margin:0;
			text-align: center;
		}
  


		#console {
		    /*width: 630px;*/
		    padding: 0;
		    font-family: "Lucida Console", Monaco, monospace;
    		white-space: pre;
    		/*font-size: 1.6vw;*/
    		margin: :0;
    		font-size: 2.4vh;	
    		/*font-size: calc(min(1.6vw,2.4vh));	*/
    		/*line-height: 1;*/
			color:white;
		}
		.col1 {
			color:white;
			background-color: black;
		}
		.col2 {
			color:gray;
			background-color: black;
		}
		.col3 {
			color:darkgray;
			background-color: black;
		}
		.col4 {
			color:darkgreen;
			background-color: black;
		}
		.col5 {
			color:blue;
			background-color: black;
		}
		.col6 {
			color:green;
			background-color: black;
		}
		.col7 {
			color:red;
			background-color: black;
		}
		.col8 {
			color:yellow;
			background-color: black;
		}
		.col9 {
			color:fuchsia;
			background-color: black;
		}
		.col0 {
			color:purple;
			background-color: black;
		}
		.col10 {
			color:lightblue;
			background-color: black;
		}
		.col11{/*status-bar*/
			color:black;
			background-color: #333333;
		}
		u {			
			/*font-weight: bold;*/
			background-color: black;
		}
	</style>

</head>

<body>

<div id="console">
	Loading game (requires javascript)
</div>

<script type="text/javascript" src="soundjs-NEXT.min.js"></script>

<script>


function playSound(id,vol=0.2){
	if (audio==="1"){
		console.log("PLAYSOUND"+id)
		let a = createjs.Sound.play(id);
		a.volume=vol;
	}
}

function setVal(key,val){
	if (typeof(Storage) !== "undefined") {
	    localStorage.setItem(key,val);
	}
}

let f = x => x*2

function getVal(key, default_val){
	if (typeof(Storage) !== "undefined") {
	    let val = localStorage.getItem(key);
	    if (val===null){
	    	return default_val;
	    } else {
	    	return val;
	    }
	} else {
    	return default_val;
	}
}


//from https://jsfiddle.net/Dwaaren/j9zahaLL/
	function vwTOpx(value) {
    let w = window,
      d = document,
      e = d.documentElement,
      g = d.getElementsByTagName('body')[0],
      x = w.innerWidth || e.clientWidth || g.clientWidth,
      y = w.innerHeight|| e.clientHeight|| g.clientHeight;

    let result = (x*value)/100;
    return result;
  }

  function vhTOpx(value) {
    let w = window,
      d = document,
      e = d.documentElement,
      g = d.getElementsByTagName('body')[0],
      x = w.innerWidth || e.clientWidth || g.clientWidth,
      y = w.innerHeight|| e.clientHeight|| g.clientHeight;

    let result = (y*value)/100;
    return result;
  }

 //end borrow

function handleresize(){
	//calc(min(1.6vw,2.4vh));
	let vw=1.6;
	let vh=2.75;
	let px_16vw = vwTOpx(vw);
	let px_24vh = vhTOpx(vh);

	console.log(px_16vw,px_24vh);
	let textbox = document.getElementById("console");

	if (px_16vw<px_24vh){
		textbox.style.fontSize=vw+"vw";
	} else {
		textbox.style.fontSize=vh+"vh";
	}
}

let Planet_Eingeweide = [  
[
"                ",
"   /  \\        ",
"  |  _|        ",
"  |_/   _/\\___ ",
"       /      \\"
],
[
"                ",
" |     _/  \\_/ ",
" \\   _|   _    ",
"  |_/   _/ \\_/\\",
"       /      |"
],
[
"                ",
" /  /  /  /  /  ",
"/  /  /  /  /  /",
"  /  /  /  /  / ",
" /  /  /  /  /  "
],
[
"                ",
"       _       _",
"\\_   _/ \\_   _/ ",
"  \\_/     \\_/   ",
"                "
],
[
"                ",
" _              ",
"/ \\      _       ",
"\\_/     / \\     ",
"        \\ /     "
],
[
"                ",
"|  |   |    |  ",
"    ---      --",
"   --     ---- ",
"  |  |   |    |",
],
[
"                ",
"       /  \\     ",
"   _ _/  _/    _",
"\\_/ X  _/  /\\_/ ",
"   / \\/   /     ",
],
[
"                ",
"  ,  ,   ,    , ",
",     ,    ,    ",
"   ,    ,    ,  ",
"                ",
],
[
"                ",
" | |   |   |    ",
" | |   |___|    ",
" |_|  __   ___  ",
"     |  | |   | ",
],
[
"                ",
"    /  _    \\   ",
"   |  / \\_   \\  ",
"  /  |    \\__|  ",
" |    \\         ",
],
[
"                ",
" /\\// __   _/\\  ",
"//\\/ /__\\_/_/\\\\_",
"/   //  \\_/   \\_",
"   ||           ",
]
];

let planet_cursor_highlight = [
` __      __ 
|          |
|          |
            
            
|          |
|__      __|`,
`888888888888
888888888888
888888888888
888888888888
888888888888
888888888888
888888888888`,
`.##......##.
#..........#
#..........#
............
............
#..........#
###......###`
]




let planet_umriss = [
"   __   ",
" /    \\ ",
"|      |",
"|      |",
" \\____/ "
];

let planet_maske = [
"        ",
"  oooo  ",
" oooooo ",
" oooooo ",
"  oooo  "
]


let planet_aussere_maske = 
`...##...
.######.
########
########
.######.`;



let planet_umriss_vvsm = 
` _ 
|_|`;

let planet_vvsm_aussere_maske = 
`.#.
###`;

let planet_umriss_vsm = 
` __ 
/  \\
\\__/`;

let planet_vsm_aussere_maske = 
`.##.
####
####`;

let planet_umriss_sm = 
`  ___  
 /   \\ 
|     |
 \\___/ `;

let planet_sm_aussere_maske = 
`..###..
.#####.
#######
.#####.`;

function fillRect(c,w,h){
	let r = "";
	for (let i=0;i<h;i++){
		for (let j=0;j<w;j++){
			r+=c;
		}
		if (i<h-1){
			r+="\n";
		}
	}
	return r;
}

function getStrW(s){
	return (s+"\n").indexOf("\n");
}
function getStrH(s){
	return (s.length+1)/(getStrW(s)+1)
}

function pickMipMap(anims,d){
	if (d>anims[0][0]){
		return null;
	}

	for (let i=1;i<anims.length-1;i++){
		let anim=anims[i];
		if (d>anim[0]){
			return anims[i-1];
		}
	}
	return anims[anims.length-1];
}

function genAllFrames(sourceLayout,waterIndex,landIndex){
	let anims=[
	//d,w,h,frames
		[10000,0,0,[[" ",""+waterIndex,"#"]]],
		[100,0,0,[[".",""+waterIndex,"#"]]],
		[7,0,0,[[".",""+waterIndex,"#"]]],
		[6,0,0,[["o",""+waterIndex,"#"]]],
		[5,0,0,[["O",""+waterIndex,"#"]]],
		[4,0,0,[[planet_umriss_vvsm,fillRect(waterIndex,3,2),planet_vvsm_aussere_maske]]],
		[3,0,0,[[planet_umriss_vsm,fillRect(waterIndex,4,3),planet_vsm_aussere_maske]]],
		[2,0,0,[[planet_umriss_sm,fillRect(waterIndex,7,4),planet_sm_aussere_maske]]],
		[1,0,0,genBigFrames(sourceLayout,waterIndex,landIndex)]
	];	
	for(let i=0;i<anims.length;i++){
		let anim = anims[i];
		let frame1 = anim[3][0][0];
		anim[1]=getStrW(frame1);
		anim[2]=getStrH(frame1);
	}
	return anims;
}

//color indices 5->9
function genBigFrames(sourceLayout,waterIndex,landIndex){
	let anim=[];
	let eingeweide = Planet_Eingeweide[sourceLayout];

	for (let i=0;i<15;i++){

		let planetkonturen="";
		let farbemaske="";

		for (let y=0;y<5;y++){
			for (let x=0;x<8;x++){
				let stringindex=x+8*y;
				let c = planet_umriss[y][x];
				let f = waterIndex;
				if (planet_maske[y][x]==="o")
				{
					let eingeweide_index = (8+x+i)%15;
					let egi = eingeweide[y][eingeweide_index];
					if (egi!==" ") {
						c = egi;
						f=landIndex;
					}
				}
				planetkonturen+=c;
				farbemaske+=f;
			}
			if (y<4){
				planetkonturen+="\n";
				farbemaske+="\n";
			}
		}

		let frame = [planetkonturen,farbemaske,planet_aussere_maske]
		anim.push(frame);
	}
	return anim;
}


let abschleppwagen = [
`                 _      
               /  |     
             / / |      
           / /   |     .
    ____ / / ____|___/_|
  /  |   | /           |
 |___|   | \\ __________|
|        |_________   \\|
|   __    _________|    
|_/    \\_|____/  \\_|    
   \\__/       \\__/      `,
`888888888888888888888888
888888888888888888888888
888888888888888881888888
888888888888888881888882
888888888888822221222222
882888888882888888888882
828888888882822222222222
888888888888888888888822
888888888888888888888888
888888888822222882228888
888333388888883333888888`,
`.................#......
...............####.....
.............#####......
...........#######.....#
....####################
..######################
.#######################
###################...##
####################....
####################....
...####......#####......`
];

let keintreibstoff_zeichen = [
`     _____     
   /       \\   
 /    __  \\  \\ 
|    |__|  |  |
|    |  |\\/   |
 \\   |__|    / 
   \\ _____ /   `,
`222222222222222
222222222222222
222222772272222
222227777227222
222227227772222
222227777222222
222222222222222`,
`     #####     
   #########   
 ############# 
###############
###############
 ############# 
   #########   `
];

let raumschiff_bilder = [	
	[
		-5,
		[
`     /\\    
    |  |   
    |  |   
    |  |   
   /|  |\\  
 /__|__|__\\
     vv    `,
`33333333333
33333333333
33333333333
33333333333
33333333333
33333333333
33333883333`,
`.....##....
....####...
....####...
....####...
...######..
.##########
.....##....`
		]
	],

	[
		-5,
		[
`     /\\    
    |  |   
    |  |   
    |  |   
    || |   
   /_|_|\\ 
     vv    `,
`33333333333
33333333333
33333333333
33333333333
33333333333
33333333333
33333883333`,
`.....##....
....####...
....####...
....####...
....####...
...######..
.....##....`
		]
	],

	[
		-5,
		[
`     /\\    
    |  |   
    |  |   
    |  |   
    | ||   
    |_||   
     vv    `,
`33333333333
33333333333
33333333333
33333333333
33333333333
33333333333
33333883333`,
`.....##....
....####...
....####...
....####...
....####...
....####...
.....##....`
		]
	],

	[
		-5,
		[
`     /\\    
    |  |   
    |  |   
    |  |   
    |  |   
   /|_|_\\  
     vv    `,
`33333333333
33333333333
33333333333
33333333333
33333333333
33333333333
33333883333`,
`.....##....
....####...
....####...
....####...
....####...
...######..
.....##....`
		]
	],

	[
		-5,
		[
`     /\\    
    |  |   
    |  |   
    |  |   
   /|  |\\  
 /__|__|__\\
           `,
`33333333333
33333333333
33333333333
33333333333
33333333333
33333333333
33333883333`,
`.....##....
....####...
....####...
....####...
...######..
.##########
...........`
		]
	],
]

let planet_anim = [
[//1
`   __
 /    \\
|    | |
|_   |_|
 \\\\__ /
`,
`   55
 566665
56666665
56666665
 565555
`
],
[//2
`   __
 /   /\\
|   |  |
|   |_/|
 \\___ /
`,
`   55
 566665
56666665
56666665
 555555
`
],
[//3
`   __
 /  / \\
|  |  _|
|  |_/ |
 \\___ /
`,
`   55
 566665
56666665
56666665
 555555
`
],
[//3b
`   __
 / /  \\
| |  _||
| |_/  |
 \\___ /
`,
`   55
 566665
56666665
56666665
 555555
`
],
[//4
`   __
 /   \\\\
||  _| |
||_/   |
 \\___ /
`,
`   55
 566665
56666665
56666665
 555555
`
],
[//5
`   __
 /  \\ \\
|  _|  |
|_/    |
 \\___//`,
`   55
 566665
56666665
56666665
 555565
`
],
[//6
`   __
 / \\  \\
| _|   |
|/    _|
 \\__/_/`,
`   55
 566665
56666665
56666665
 555655
`
],
[//7
`   __
 /\\   \\
|_|    |
|   _/\\|
 \\/__ /`,
`   55
 566665
56666665
56666665
 565555
`
],
[//8
`   __
 /    \\
||     |
| __/\\_|
 \\___ /
`,
`   55
 566665
56666665
56666665
 555555
`
],
[//9AAA
`   __
 /    \\
|      |
| _/\\__|
 \\___ /
`,
`   55
 566665
56666665
56666665
 555555
`
],
[//9AAA
`   __
 /    \\
|      |
| /\\__ |
 \\___ /
`,
`   55
 566665
56666665
56666665
 555555
`
],
[//10
`   __
 /    \\
|      |
|\\___  |
 \\___\\/
`,
`   55
 566665
56666665
56666665
 555565
`
],
[//11
`   __
 /    \\
|      |
|\\__   |
 \\__\\_/
`,
`   55
 566665
56666665
56666665
 555655
`
],
[//12
`   __
 /    \\
|     ||
|__   ||
 \\_\\_ /
`,
`   55
 566665
56666665
56666665
 556555
`
]

]

let leveldats =  [
	[//DEU	
		[//L1		
			["TOR",2],
			["ORT",0],
			["ROT",0],
		],
		[//l2

			["EHRE",2],
			["REHE",0],
			["HEER",0],
			["EHER",0],
		],
		[//L3		
			["SEIEN",1],
			["SEINE",1],
			["EISEN",1],
			["EINES",0],
		],
		[//L4
			["LISTE",2],
			["EILST",1],
			["LEIST",0],
			["LIEST",0],
			["STIEL",1],
			["SEILT",0],
			["SIELT",0],
			["STEIL",0],
			["STILE",0],
			["TEILS",0]
		],
		[//L5
			["FEIERN",2],
			["EIFERN",0],
			["FREIEN",1],//KÖNNTE AUCH DAS PUNKTE GEBEN (STATT FERIEN)
			["FERIEN",0],
			["RIEFEN",0],
			["REIFEN",0],
		],
		[//L6
			["REISEN",1],
			["RIESEN",2],
			["REINES",1],
			["SERIEN",0],
			["SIRENE",0],
			["SEINER",0],
			["EISERN",0],
			["EINSER",0],
		],
		[//L7
			["SCHEINEN",1],
			["SCHIENEN",1],
			["SCHNEIEN",4],
			["CHINESEN",1],
		],
		[//L8
			["STREICHEN",5],
			["SCHEITERN",3],
			["SCHREITEN",3],
			["SICHERTEN",0],
			["REICHSTEN",0],
		],

	],
	[//eng
		[//l1
			["star",1],
			["tsar",1],
			["tars",0],
			["arts",0],
			["rats",0]
		],
		[//l2
			["east",1],
			["eats",1],
			["seat",0],
			["sate",0],
			["teas",0],
		],
		[//l3
			["trees",2],
			["terse",2],
			["steer",1],
			["ester",0],
			["reset",0]
		],
		[//l4
			["steak",2],
			["stake",1],
			["skate",1],
			["teaks",0],
			["takes",0]
		],
		[//l5
			["parse",1],
			["apres",1],
			["rapes",1],
			["pares",0],
			["reaps",0],
			["pears",0],
			["spare",0],
			["spear",0],
		],
		[//l6
			["pleats",2],
			["plates",1],
			["palest",1],
			["petals",1],
			["pastel",1],
			["staple",0],
		],
		[//lv7
			["parsley",2],
			["parleys",0],
			["sparely",0],
			["players",0],
			["replays",0],
		],
		[//l8
			["hatreds",4],
			["threads",1],
			["hardest",1],
			["trashed",4],
			["dearths",0]
		],
	]
]
let wordLength=3;
let vis=[];

let titelwords = ["dcba","dcab","dbac","dbca","dabc","dacb","cdba","cdab","cbad","cbda","cabd","cacb","bcda","bcad","bdac","bdca","badc","bacd","acbd","acdb","abdc","abcd","adbc","adcb"]


let level=0;
let gameState="TITEL";

let words = titelwords;
let rewards=[];
let visitedlist=[];

// let words = ["12345","21345","31245","13245","23145","32145","32415","23415","43215","34215","24315","42315","41325","14325","34125","43125","13425","31425","21435","12435","42135","24135","14235","41235","51234","15234","25134","52134","12534","21534","21354","12354","32154","23154","13254","31254","35214","53214","23514","32514","52314","25314","15324","51324","31524","13524","53124","35124","45123","54123","14523","41523","51423","15423","15243","51243","21543","12543","52143","25143","24153","42153","12453","21453","41253","14253","54213","45213","25413","52413","42513","24513","34512","43512","53412","35412","45312","54312","54132","45132","15432","51432","41532","14532","13542","31542","51342","15342","35142","53142","43152","34152","14352","41352","31452","13452","23451","32451","42351","24351","34251","43251","43521","34521","54321","45321","35421","53421","52431","25431","45231","54231","24531","42531","32541","23541","53241","35241","25341","52341"]
// let words = ["apres", "asper", "pares", "parse", "pears", "spear", "spare", "rapes", "reaps", "apers"]
// let words = ["dcba","dcab","dbac","dbca","dabc","dacb","cdba","cdab","cbad","cbda","cabd","cacb","bcda","bcad","bdac","bdca","badc","bacd","acbd","acdb","abdc","abcd","adbc","adcb"]
// let words = ["bepis","ebpsi","bpeis"]
// let words = ["cba","cab","bac","bca","abc","acb"]

function permToStr(p){
	let r = "";
	for (let i=0;i<p.length;i++){
		r+=p[i].toString(16);
	}
	return r;
}

let perms = [];
let rperms = [];
let perms_str = [];
let rperms_str = [];

function generateWordPerms(){
	perms=[];
	rperms=[];
	perms_str = [];
	rperms_str = [];

	let base = words[0];
	for (let i=0;i<words.length;i++){
		let word = words[i];
		let perm=[];
		let rperm=[];
		for (let j=0;j<word.length;j++){
			let basechar = base[j];
			let wordchar = word[j];
			perm.push(word.indexOf(basechar));
			rperm.push(base.indexOf(wordchar));
		}
		perms.push(perm);
		rperms.push(rperm);

		perms_str.push(permToStr(perm));
		rperms_str.push(permToStr(rperm));
	}
}

let wort = "epbis";
let baseword = wort;
let cursorPos=1;
let lastCursorPos=cursorPos;
let cursorPos_Base=cursorPos;

function permToVec(p){
	// console.log (" p = "+p);
	let dim=p.length;
	let s =0;
	for (let i=0;i<p.length;i++){
		    s+=p[i];
	}	
	let v1 = p.slice();
	for (let i=0;i<v1.length;i++){
		v1[i]=(v1[i]);
	}
	// console.log (" v1 = "+v1);

	let v2 = [];
	for (let i=1;i<p.length;i++){
		v2.push(2*(p[i]-(dim-1)/2)/dim);
	}
	v2=normalizedVect(v2);
	v2=smul(0.7,v2)
	// console.log( "v2 = "+v2)
	while(v2.length<3){
		v2.push(v2.length);
	}
	return v2;
}


function vectSlerp(start,end,percent){
     // Dot product - the cosine of the angle between 2 vectors.
     let d = dot(start, end);     
     // Clamp it to be in the range of Acos()
     // This may be unnecessary, but floating point
     // precision can be a fickle mistress.
     if (d<-1){
     	d=-1;
     }
     if (d>1){
     	d=1;
     }

     let theta = Math.acos(d)*percent;
     relativeVec = vectSub(end ,smul(d,start));
     relativeVec = normalizedVect(relativeVec);
     return vectAdd( smul(Math.cos(theta),start) , smul(Math.sin(theta),relativeVec) );
}

function vectLerp(v1,v2,a){
	let r = [];
	for (let i=0;i<v1.length;i++){
		r.push((1-a)*v1[i]+a*v2[i]);
	}
	return r;
}

function vectAdd(v1,v2){
	let r = [];
	for (let i=0;i<v1.length;i++){
		r.push(v1[i]+v2[i]);
	}
	return r;
}
function vectSub(v1,v2){
	let r = [];
	for (let i=0;i<v1.length;i++){
		r.push(v1[i]-v2[i]);
	}
	return r;
}

function vdist(v1,v2){
	let d = 0;
	for (let i=0;i<v1.length;i++){
		let diff = v2[i]-v1[i];
		d+=diff*diff;
	}
	return Math.sqrt(d);
}

function swap(v1,gap){
	let result = v1.slice();
	let t = result[gap];
	result[gap]=result[gap+1];
	result[gap+1]=t;
	return result;
}

function invertPerm(p){
	let result=[];
	for (let i=0;i<p.length;i++){
		result.push(p.indexOf(i));
	}
	return result;
}


// let p1 = perms[5];
// let p2 = invertPerm(swap(invertPerm(p1),0));

// let v1 = permToVec(p1)
// let v2 = permToVec(p2)

// console.log("p1")
// console.log(p1)
// console.log(v1)

// console.log("p2")
// console.log(p2)
// console.log(v2)

// console.log("dist = " + vdist(v1,v2));

function getRandomInt(min, max) {
  min = Math.ceil(min);
  max = Math.floor(max);
  return Math.floor(Math.random() * (max - min)) + min;
}

let col1_i = getRandomInt(0,5);
let col2_i = getRandomInt(1,5);

let c1 = col1_i+5;
let c2 = (5)+( (col1_i+col2_i)%5 );
planet_anim = genBigFrames(
	getRandomInt(0,Planet_Eingeweide.length),
	c1,
	c2
	);

// console.log(planet_anim);

	let cw = 80;
	let ch = 24;

	let letterbuffer=[];
	let colorbuffer=[];

	let dimensionen=3;
	let origin=[0,0,0,0];

	let campos=[0,0,-0.5,0];
	let oldcampos = campos;
	
	let camright=[1,0,0,0]
	let camup=[0,-1,0,0];
	let camforward=[0,0,1,0];

	function dot(v1,v2){
		let s = 0;
		for (let i=0;i<v1.length;i++){
			s+=v1[i]*v2[i];
		}
		return s;
	}

	function smul(s,v){
		let k = v.slice();
		for (let i=0;i<k.length;i++){
			k[i]=s*k[i];
		}
		return k;
	}

	function setDimensionen(n){
		dimensionen=n;
		origin=[]
		campos=[]
		camforward=[]
		camup=[]
		camright=[]

		let vecLen=Math.max(dimensionen,3)
		for (let i=0;i<vecLen;i++){
			origin.push(0);
			campos.push(0);

			camforward.push(0);
			camup.push(0);
			camright.push(0);
		}

		if (dimensionen>2){
			campos[2]=-0.5;

			camforward[2]=1;
			camup[1]=1;
			camright[0]=1;

		} else {
			campos[2]=1;

			camforward[2]=-1;
			camup[1]=1;
			camright[0]=1;			
		}
			oldcampos=campos.slice();

	}

	let sterne=[];
	let planeten=[];

	let MAX_DEPTH=10000;

	function dist(p1,p2){
		let s=0;
		for (let i=0;i<dimensionen;i++){
			let diff = p1[i]-p2[i];
			s+=diff*diff;
		}
		s=Math.sqrt(s);
		return s;
	}


	function vectLen(v){
		let d = 0;
		for (let i=0;i<v.length;i++){
			d += v[i] * v[i];
		}
		return Math.sqrt(d);
	}

	//project b onto a
	function project(b,a){
		let d = dot(a,b);
		let amag = vectLen(a);
		return smul(d/(amag*amag),a);
	}

	function normalizedVect(v){
		let l = vectLen(v);
		if (l===0){
			return v;
		}
		let result = v.slice();
		for (let i=0;i<result.length;i++){
			result[i]/=l;
		}
		return result;
	}

	function createBuffer(){
		letterbuffer=[];
		colorbuffer=[];
		depthbuffer=[];

		for (let i=0;i<cw;i++){
			let letter_r = [];
			let color_r = [];
			let depth_r = [];

			for (let j=0;j<ch;j++){
				color_r.push(0);
				letter_r.push(" ");
				depth_r.push(MAX_DEPTH);
			}
			//status-bar
			color_r.push(0);
			letter_r.push(" ");
			depth_r.push(MAX_DEPTH);

			letterbuffer.push(letter_r);
			colorbuffer.push(color_r);
			depthbuffer.push(depth_r);
		}

		sterne=[]

		
		planeten=[];


	}


	function spawnTitelPlaneten(){

		sterne=[];

		planeten=[];
		for (let i=0;i<perms.length;i++)
		{
			// let coord=[];
			// for (let j=0;j<dimensionen;j++){
			// 	coord.push((Math.random()-0.5)*2.0);
			// }
			let normalized = permToVec(perms[i]);
			let col1_i = getRandomInt(0,5);
			let col2_i = getRandomInt(1,5);
			let c1 = col1_i+5;
			let c2 = (5)+( (col1_i+col2_i)%5 );
			let my_planet_anim = genAllFrames(
				getRandomInt(0,Planet_Eingeweide.length),
				c1,
				c2
				);

			let planet = [normalized,my_planet_anim];

			planeten.push(planet);

		}


	}

	function spawnSpielPlaneten(){

		// for (let i=0;i<perms.length;i++)
		{
			let i =2;
			// let coord=[];
			// for (let j=0;j<dimensionen;j++){
			// 	coord.push((Math.random()-0.5)*2.0);
			// }
			let normalized = permToVec(perms[i]);
			let col1_i = getRandomInt(0,5);
			let col2_i = getRandomInt(1,5);
			let c1 = col1_i+5;
			let c2 = (5)+( (col1_i+col2_i)%5 );
			let my_planet_anim = genAllFrames(
				getRandomInt(0,Planet_Eingeweide.length),
				c1,
				c2
				);

			let planet = [normalized,my_planet_anim];

			planeten.push(planet);
		}
	}

	function CoordToScreenSpace(wordpos){
		let cx = Math.round(cw/2);
		let cy = Math.round(ch/2);

		let coord = vectSub(wordpos,campos);
		let sx = dot(coord,camright);
		let sy = dot(coord,camup);
		let d = dot(coord,camforward);


		if(gameState ==="TITEL")
		{
			d=d*10;
		}
			
		sx*=1.8*cx/(2);
		sy*=1.8*cy/(2);


		sx = Math.round(sx);
		sy = Math.round(sy);

		if(gameState==="SPIEL"){
			sy-=3;
		} else if (gameState==="SEQUENZ"){
			sy+=2;
		}
		// sx-=60;

		return [d,[sx,sy]];
	}

	function drawSprite(planet,highlight){

		let cx = Math.floor(cw/2);
		let cy = Math.floor(ch/2);

		let s = CoordToScreenSpace(planet[0]);

		let d = s[0];
		if (dimensionen===2){
			d/=2;
		}
		if (d<0){
			return;
		}
		let sx=s[1][0];
		let sy=s[1][1];

		let mipmaps = planet[1];


		let frame_dat = pickMipMap(mipmaps,d);


		let framew=frame_dat[1];
		let frameh=frame_dat[2];
		let frames=frame_dat[3];

		let frameo_x=-Math.round(framew/2);
		let frameo_y=-Math.round(frameh/2);

		sx+=cx+frameo_x;
		sy+=cy+frameo_y;
		

		if (frames===null){
			return;
		}
			


		// sx-=60;


		let frame = Math.floor(frames.length*time/(3*1000))%frames.length;
		blit(frames[frame],sx,sy,d);

		if (highlight){
			let frame = Math.floor(frames.length*time/(3*1000))%frames.length;
			blit(planet_cursor_highlight,sx-2,sy-1,0);			
		}

	}

	function blit(img,x,y,depth){		
		let text=img[0].split("\n");
		let cols=img[1].split("\n");
		let mask=img[2].split("\n");

		let w =text[0].length;
		let h = text.length;

		if (x>=cw || y>=ch || x+w<=0 || y+h<=0){
			return;
		}
				

		for (let i=0;i<text.length;i++){
			for (let j=0;j<text[i].length;j++){
				if (x+j<0 || y+i<0 || x+j>=cw || y+i>=ch){
					continue;
				}

				if ( mask[i][j] === "." || depthbuffer[x+j][y+i]<depth){
					continue;
				}

				let b = text[i][j];
				let col = cols[i][j];				

				letterbuffer[x+j][y+i]=b;
				colorbuffer[x+j][y+i]=col;
				depthbuffer[x+j][y+i]=depth;
			}
		}
	}

	function clearBuffer(){

		for (let i=0;i<cw;i++){
			for (let j=0;j<ch;j++){
				letterbuffer[i][j]=" ";
				colorbuffer[i][j]=1;
				depthbuffer[i][j]=MAX_DEPTH;
			}
		}
	}

	function onInput(k){
		if (k===6&&gameState!=="TITEL"){
			setGameState("TITEL");
			return;
		}
		switch(gameState){
			case "TITEL":
			onTitelInput(k);
			break;
			case "SEQUENZ":
			onSequenzInput(k);
			break;
			case "SPIEL":
			onSpielInput(k);
			break;
		}
	}

	function toggleAudio(){
		if (audio==="1"){
			audio="0";
		} else {
			audio="1";
		}

		setVal("audio",""+audio);
		playSound(2);
	}

	function toggleSprache(){
		if (sprache==="DE"){
			sprache="EN";
		} else {
			sprache="DE";
		}

		let menügröße = getVal("level"+sprache,0)===0?3:4;
		startcursorIndex=menügröße-1;
		setVal("sprache",sprache);

		playSound(2);
	}

	function onTitelInput(k){

		if (exitanim<exitanimdauer || gameState!=="TITEL"){
			return;
		}

		let menügröße = getVal("level"+sprache,0)===0?3:4;
		let audiooption = (menügröße===3 && startcursorIndex===1) || (menügröße===4 && startcursorIndex===2);
		let spracheoption = (menügröße===3 && startcursorIndex===2) || (menügröße===4 && startcursorIndex===3);
		let neuesspiel = startcursorIndex===0;
		let fortsetzen = menügröße===4 && startcursorIndex===1;

		switch(k){
			case 0://u
			if (startcursorIndex>0){
				startcursorIndex--;				
				playSound(1);
			}
			break;
			case 1://d
			if (startcursorIndex+1<menügröße){
				startcursorIndex++;
				playSound(1);
			}
			break;
			case 2://l
				if (audiooption){
					toggleAudio();
				}
				if (spracheoption){
					toggleSprache();
				}
			break;
			case 3://r
				if (audiooption){
					toggleAudio();
				}
				if (spracheoption){
					toggleSprache();
				}
			break;
			case 4://x
				playSound(3);
				if (audiooption){
					toggleAudio();
				}
				if (spracheoption){
					toggleSprache();
				}
				if (fortsetzen){
					level=getVal("level"+sprache,0);
					exitanim=0;
				}
				if (neuesspiel){
					level=0;
					exitanim=0;
				}
			break;
		}

	}


let	sequenzenDat = [
`
----
LEVEL1 star
----
Welcome to the Galactic Center for Etymological Research, or ERCG for short.
Your project at ERCG is to map out all the planet names in various systems, and hopefully to help us understand where these names come from!
Planet names often don't seem to make much sense.
Like your home planet.
ZEIG
Star? Star! What's that about even?
Anyway, you've been allocated a spaceship.  
You may travel with it as you please.
The fuel is currently limited, so you can only hop between neighbouring planets.  
BUT in principle it can be upgraded, so you should be able to go further afield if you can manage that.
You will always be able to refuel when you land on a planet.
Okay, that's everything.
Welcome, get going, and have fun :)
----
LEVEL2 east
----
The cardinal directions of north, south, east and west have no meaning in space.
Or they shouldn't, but, well...look at where your next assignment is sending you:
ZEIG
East? Really? Who named these things anyway?
Excuse my French, I'm sure the people who named it did so for reasons important to them.
I just wish they'd explain it to the rest of us!
Well, don't mind my ranting.  I'm sure you're itching to get going...
----
LEVEL3 trees
----
Things exist at different scales, from atomic scale to galactic scale.
Things at different levels don't typically interact with each other.
But names have physical laws all of their own.
Exemplified by our next point of departure
ZEIG
Yip, planet "tree".
I hope you manage to find some more appropriate-named planets on your trip today.
----
LEVEL4 steak
----
Do you want to eat a steak burger?
Oh you do?  Steak is indeed delicious.
How about steak fries? 
Or steak strawberries?
Well you're in luck, because we're going to planet...
ZEIG
Yip, planet "Steak".  
Sorry.  Bad joke.
Have a lovely day, and good luck finding an actual steak, lol.
----
LEVEL5 parse
----
We give things names, but often the meaning is quickly lost or obscured, and we are just left with words.
Things are things and words are words.
If I call you ROBOT it's just a word.  It does't change anything about you.
BUT it might reflect something about you.  
That's the hope of our research, to see in what ways the meanings of words reflect the true essence of things.
That said, in the case of our current planet, any possible meaning is rather obscure.
ZEIG
Anyway, don't let me keep you.  Have fun mapping out this system!
----
LEVEL6 pleats
----
Planets are round.
This planet, being a planet, is round.
ZEIG
But it's called "Pleats"
These planets continue to be strangely named.  
Sometimes I fear that the search for meaning is futile.
Sometimes I fear that there's no sense to this at all...
----
LEVEL7 parsley
----
I just had a thought.
The planets are not arranged in an orderly fashion, but, using our planetary coordinate system.
It seems that wherever there is a word there is in the corresponding spot planet.
Maybe, instead of naming planets after things, we named *things* after *planets*?
Like I said, just a thought.
Now, proceeding to the matter at hand:
Gaia theory posits that plants are living organisms.
So maybe it's grand that this planet is named "Parsley".
ZEIG
I wonder how many other planets are named after herbs?
----
LEVEL8 hatreds
----
Words grow and perish, and planets grown and perish.
I've been looking at historical data.
It seems that new word comes into use, a planet springs into existence at those very coordinates.
And when a word falls out of use, the planet vanishes.
It seems the relationship between names and planets was not, that we give planets names, but that words give us planets.
This raises the question:
How did the first world come into existence?
Let's thing about this more over the next assignment, and let's can more when you're back.
Oh, right! The mission.  
Your final mission!
Well, this is a name that could be assigned to about any planet that there's been life on.
ZEIG
Let's hope this one isn't particularly egregious.
----
END
----
To part one's lips and speak a word is to create a world.
Words are worlds and worlds are words.
We thought we were searching for meaning, but we were just searching for words.
Our mission's over.
Let us meet another time, to start a new search:
A search for meaning beyond words, and beyond worlds.
`,
`
----
LEVEL1 TOR
----
Herzlich willkommen im Galaktischen Etymologieforschungsinstitut, kurz GEFI genannt.
Ihr Projket hier ist eines zu den Ursprünge der Planetennamen.
Das heißt, eine Datenbank davon zu Sammeln, und unser Wissen darüber zu vertiefen.
Planetnnamen macht oft nicht so viel sinn. Aber dieses Mal doch, es macht sin.
ZEIG
Sie werden von diesem Planeten, Tor, aufbrechen.
Lassen Sie dieses Projekt als Tor deiner Zukunft sein.
Ein Raumschiff ist Ihnen zugeteilt worden.
Sie dürfen reisen, wohin Sie wollen.
Wohin Sie wollen, und wohin Sie genug Treibstoff hast, um zu fahren.
Das heißt, die Treibstoffskapazität Ihres Schiffs ist ziemlich niedrig.
So niedrig, dass Sie im Moment nur zwischen benachbarten Planeten fliegen können.
ABER Sie sollten es vergrößern können.
Treibstoff ist selbst kein Problem, nur die Kapazität.  Sie können immer auf Planeten auftanken. 
Das war's, ich glaube.
Ich wünsche Ihnen viel Spaß dabei.
----
LEVEL2 EHRE
----
Eine Person kann ehre haben, das würde ich zugeben.
ZEIG
Aber ein Planet? Ne, das würde ich nicht.
Leute sagen immer, wie wunderschön es aussieht.
Aber, obwohl Etymologie selbst ist wunderschön,  Wunderschönheit ist keine Etymologie!
Ich verstehe nicht, aber - aber auch ohne Verständnis sollten wir trotzdem vorankommen können.
Wir müssen mehr Datenpunkte sammeln.
----
LEVEL3 SEIEN
----
Sei X ein Planet.
ZEIG
Es könnte gesagt werden, dass Dieser Planet nicht länger als sein Name bestehen wird.
Was für Logic würde zu diesen Namen führen?  
Worin liegt die Wissenschaft?
----
LEVEL4 LISTE
----
Was erstellen Sie?  Eine Datenbank? 
Nee, Datenbanken haben Struktur.
ZEIG
Sie erstellen nicht. 
Sie schreiben nur eine Liste.  
Die Struktur, die Logic, die Wissenschaft fehlen komplett.
Was ist dann der Sinn Ihrer Forschung?
----
LEVEL5 FEIERN
----
Der Grund, warum etwas so gennant wurde, kommt uns oft schnell abhanden.
Hier haben wir viele Planeten mit vielen Namen, und die Namen haben selbst alle Bedeutungen. 
Aber Bedeutungen ohne Gründe sind keine Bedeutungen.
Seien Dingsbums Dingsbums und Wörter nur Wörter.
Wenn ich Ihnen ROBOTER nennen würde, was hat das mit Ihrem Inbegriff zu tun?
Aber die Bedeutung dieses Namens könnte etwas Wahr an Ihnen spiegeln.
Die große Hoffnung unserer Forschung ist die Wege zu finden, wodurch Wesen und Wörter verkoppelt werden können.
Nur zu diesem Zeitpunkt werden wir feiern können.
ZEIG
Das Wort reicht mir nicht.  
Ich will nicht "feiern" sondern feiern!
----
LEVEL6 REISEN
----
Wir reisen hierher und dorthin.
ZEIG
Wich suchen nach Wissen und Sinn.
Aber Sie weichen uns aus.
Ich fürchte, wir werden die Antwort nicht finden.
Ich fürchte, es gibt weder Antwort, noch Wissen, noch Sinn.
----
LEVEL7 SCHEINEN
----
Ich habe eine Idee.
Es scheint mir
ZEIG
Es scheint mir, dass die Planeten und ihre Namen..., dass die nicht geordnet sind.
Aber warum habe wir nur Planeten beobachtet genau wo die Koordinaten bilden?
Es könnte nicht der Fall sein, dass Planeten nach ihren Eigenschaften benannt sind.
Könnte es der Fall sein, dass *Begriffe* nach *Planeten* benannt wurden?
Wie gesagt, nur eine Vermutung.
----
LEVEL8 STREICHEN
----
Die immer weiter laufende Zeit streicht beide Wort und Welt weg.
ZEIG
Wörter wachsen und werden welk, und Welten wachsen und werden welk.
Ich habe die Vergangenheitsdaten überprüft.
Es scheint der Fall zu sein, wenn ein Wort in Gebraucht kommt, entsteht in seinen entsprechenden Koordinaten ein neuer Planet.
Und im Fall ein Wort ganz vergessen ist, wird der entsprechende Planet auch erlöscht.
Es scheint der Fall zu sein, dass die Beziehung zwischen Namen und Planeten ist nicht, dass wir die Planeten genannt haben, sondern dass Namen uns Planeten gegeben haben.
Das wirft eine Frage auf:
Woher komm dann der erste Planet? Von der Stimme des Nichts?
----
END
----
Der Mund zu offnen bedeutet Welten zu schaffen.
Wörter sind Welten und Welten sind Wörter.
Wir dachten, wir suchten nach Sinn, aber wir suchten tatsächlich nach Wörter.
Damit ist unsere Arbeit getan.
Lass uns ein anderes Mal treffen, eine neue Suche durchzuführen:
Eine Suche des Wortes und der Planeten jenseits.
`
	]
	
let sequenzen =[];

	function prozessSequenzen(){
		sequenzen=[
		[[],[]],
		[[],[]],
		[[],[]],
		[[],[]],
		[[],[]],
		[[],[]],
		[[],[]],
		[[],[]],
		[[],[]],
		];

		let teile=[];
		for (let isprache=0;isprache<2;isprache++){
			let teil=[];
			let text=sequenzenDat[1-isprache];
			let sections = text.trim().split('----');
			for (let ilevel=0;ilevel<9;ilevel++){
				//j is level
				let sectionindex = 2+ilevel*2;
				let leveltext=sections[sectionindex].trim();
				let linien=leveltext.split("\n");
				for(let k=0;k<linien.length;k++){
					let satz = linien[k].trim();
					if (satz==="ZEIG"){
						sequenzen[ilevel][isprache].push(["WORT","WORT"]);
					} else {
						sequenzen[ilevel][isprache].push(["SAG",satz])
					}
				}
			}
		}
		console.log(sequenzen);
	}

	prozessSequenzen();


	function onSequenzInput(k){
		if (sequenzEnde<sequenzEndeDauer){
			return;
		}

		switch(k){
			case 0://u
			break;
			case 1://d
			break;
			case 2://l
			break;
			case 3://r
			break;
			case 4://x
			// console.log(sichtbareBuchstaben+","+sichtbarerText.length)
			if (sichtbareBuchstaben<sichtbarerText.length){
				sichtbareBuchstaben=sichtbarerText.length;
				// playSound(2);
			} else {

				// playSound(1);
				sequenzSchritt();
			}
			break;
		}

	}

	function onSpielInput(k){

		if (k===6){//esc
			setGameState("TITEL");
			return;
		}

		if (endanim<endanimdauer || wonlevel){			
			if (k===4&&wonlevel && flyawayanim>=flyawayanimdauer){
				playSound(7);
				flyawayanim=0;
			}
			return;
		}

		// if (bewegunganimation<bewegunganimationdauer){
		// 	return;
		// }
		if (tauschanimation<tauschanimationdauer){
			return;
		}
		oldcampos=campos;
		switch(k){
			case 0://u
			break;
			case 1://d
			break;
			case 2://l
				if (fuelreward){
					break;
				}
				if (cursorPos>0 && fuelamount>0){
					tauschanimation=tauschanimationdauer;
					lastCursorPos=cursorPos;
					// bewegunganimation=0;
					cursorPos--;	
					playSound(1);
				}
			break;
			case 3://r
				if (fuelreward){
					break;
				}
				if (cursorPos<wort.length-2 && fuelamount>0){
					tauschanimation=tauschanimationdauer;
					lastCursorPos=cursorPos;
					// bewegunganimation=0;
					cursorPos++;
					playSound(1);
				}
			break;
			case 4://x
				if (fuelreward){
					fuelreward=false;
					break;
				}
				if (fuelamount==0){
					break;
				}
				if (words.indexOf(wort)>=0 && fuelamount<fuelcapacity){
					//fuelamount=fuelcapacity;
				} else {
					playSound(2);
					wort = wort.substring(0,cursorPos)+wort[cursorPos+1]+wort[cursorPos]+wort.substring(cursorPos+2);
					fuelamount--;
					cursorPos_Base=cursorPos;
					tauschanimation=0;
					refuelingdauer=refuelingdauermax;
				}
			break;
			case 7://h
				if (outoffuel){
					playSound(5);
					recovering=true;
					outoffuel=false;
					recoverytimer=0;
				}
			break;
		}
	}

	let keyAllowed = {};

	function onFocus(e){
		keyAllowed = {};
	}

	function onKeyup(e){
		keyAllowed [e.which] = true;
	}

	function checkKey(e) {
	    e = e || window.event;

		if (keyAllowed [e.which] === false) {
			if (e.keyCode == '88' || e.keyCode =='32'||e.keyCode =='13'||e.keyCode =='68'){
				return;
			}
		}
		keyAllowed [e.which] = false;
		 
	    if (e.keyCode == '38') {
	        // up arrow
	    	onInput(0);
	    	e.preventDefault();
	    }
	    else if (e.keyCode == '40') {
	        // down arrow
	    	onInput(1);
	    	e.preventDefault();
	    }
	    else if (e.keyCode == '37') {
	       // left arrow
	    	onInput(2);
	    	e.preventDefault();
	    }
	    else if (e.keyCode == '39') {
	       // right arrow
	    	onInput(3);
	    	e.preventDefault();
	    } else if (e.keyCode == '88' || e.keyCode =='32'||e.keyCode =='13'||e.keyCode =='68'){
	    	onInput(4);
	    	e.preventDefault();
	    } else if (e.keyCode=='90'||e.keyCode=='85'){
	    	onInput(5);
	    } else if (e.keyCode=='27'){
	    	onInput(6);
	    } else if (e.keyCode=='72'){
	    	onInput(7);
	    } else if (e.keycode=='88'){
	    	onInput(8);
	    }

	}

	/**
	 * Returns a random integer between min (inclusive) and max (inclusive).
	 * The value is no lower than min (or the next integer greater than min
	 * if min isn't an integer) and no greater than max (or the next integer
	 * lower than max if max isn't an integer).
	 * Using Math.round() will give you a non-uniform distribution!
	 */
	function getRandomInt(min, max) {
	  min = Math.ceil(min);
	  max = Math.floor(max);
	  return Math.floor(Math.random() * (max - min)) + min;
	}


	function flipBuffer(){

		let text = "";
		let lastcol=-1;

		for (let j=0;j<ch+1;j++){
			for (let i=0;i<cw;i++){
				let l = letterbuffer[i][j];
				let col = colorbuffer[i][j];
				if ((j===ch||l!==" ") &&lastcol!==col){
					if (text.length>0){
						text+="</span>"
					}
					text+=`<span class="col${col}">`
					lastcol=col;
				}
				text+=l;
			}
			if (j<ch){
				text+="<br>";
			}
		}
		text+="</span>"

		let textbox = document.getElementById("console");
		textbox.innerHTML=text;
	}

	let sprache = getVal("sprache","EN");


	let startcursorIndex = getVal("level"+sprache,0)===0?0:1;

	function S(de,en){
		if (sprache==="DE"){
			return de;
		} else {
			return en;
		}
	}

	function drawBox(x,y,w,h,c){
		if (w<=0||h<=0){
			return;
		}
		letterbuffer[x][y]="+";
		letterbuffer[x+w-1][y]="+";
		letterbuffer[x][y+h-1]="+";
		letterbuffer[x+w-1][y+h-1]="+";

		colorbuffer[x][y]=c;
		colorbuffer[x+w-1][y]=c;
		colorbuffer[x][y+h-1]=c;
		colorbuffer[x+w-1][y+h-1]=c;

		for (let i=1;i<w-1;i++){
			letterbuffer[x+i][y]="-";
			letterbuffer[x+i][y+h-1]="-";

			colorbuffer[x+i][y]=c;
			colorbuffer[x+i][y+h-1]=c;

			for (let j=1;j<h-1;j++){
				letterbuffer[x+i][y+j]=" ";
			}
		}

		for (let j=1;j<h-1;j++){
			letterbuffer[x][y+j]="|";
			letterbuffer[x+w-1][y+j]="|";

			colorbuffer[x][y+j]=c;
			colorbuffer[x+w-1][y+j]=c;
		}

	}

	let fuelcapacity=4;
	let fuelamount=3;

	function printText(s,x,y,c){
		let origx=x;
		for (let i=0;i<s.length;i++){
			let char = s[i];
			if (char==="\n"){
				y++;
				x=origx-(i+1);
				continue;
			}

			if (y<0||y>ch){
				continue;
			}
			let p = x+i;
			if (p<0||p>=cw){
				continue;
			}

			letterbuffer[p][y]=char;
			colorbuffer[p][y]=c;
		}
	}


	function printRainbowText(s,x,y,length,speed){
		let o = Math.floor(speed*time/1000);
		c = 5+(Math.ceil(o/length)%5);
		for (let i=0;i<s.length;i++){
			letterbuffer[x+i][y]=s[i];
			colorbuffer[x+i][y]=c;
			if ((i+o)%length===0){
				c=c+1;
				if (c===10){
					c=5;
				}
			}
		}
	}

	let savegame=123;
	let audio=getVal("audio","1");


	let refuelingdauermax=1.0;
	let refuelingdauerblinkrate=5;
	let refuelingdauer=refuelingdauermax;

	let exitanimdauer=1.0;
	let exitanim=exitanimdauer;


	let zeigsequenzwort=false;
	let sichtbareBuchstaben=1;
	let sichtbarerText="";
	let sequenzWrapSpalten=30;
	let sichtbarerTextlinien=1;

	function spracheIndex(){		
		return sprache==="DE"?0:1;
	}

	function getStartingWort(){
		let spracheindex = spracheIndex();
		return leveldats[spracheindex][level][0][0]
	}

	function sequenzSchritt(){
		sequenzindex++;

		let spracheindex = spracheIndex();
		if (sequenzindex>=sequenzen[level][spracheindex].length){
			sequenzEnde=0;
			playSound(3);
			return;
		}

		let entry = sequenzen[level][spracheindex][sequenzindex];
		let action = entry[0];
		let txt = entry[1];
		switch(action){
			case "SAG":
			// playSound(2);
			sichtbareBuchstaben=1;
			sichtbarerText = wordwrap(txt,sequenzWrapSpalten);
			sichtbarerTextlinien =  sichtbarerText.split(/\r\n|\r|\n/).length;
			break;
			case "WORT":
			// playSound(1);
			zeigsequenzwort=true;
			wort=getStartingWort();
			break;
		}

	}

	var wordwrap_cached={};
	function wordwrap( long_string, colcount ) {
		let cached=wordwrap_cached[long_string];
		if (cached!==undefined){
			return cached;
		}
		let words = long_string.split(" ");
		let result="";
		let curlinelen=0;
		for (let i=0;i<words.length;i++){
			let word=words[i];
			if (word==="\n"){
				continue;
			}
			if (curlinelen+1+word.length > colcount){
				result+="\n";
				curlinelen=0;
			} else {
				if (i>0){
					result+=" ";
					curlinelen++;
				}
			}

			result+=word;
			let nll = word.lastIndexOf("\n");
			if (nll>=0){
				curlinelen=word.length-(nll+1);
			} else {
				curlinelen+=word.length;
			}
		}
	 	wordwrap_cached[long_string]=cached;
		return result;
	}

	function isLetter(c) {
	  return c.toLowerCase() != c.toUpperCase();
	}

	function renderSequenzoberfläche(){

		if (sequenzEnde<sequenzEndeDauer){
			sequenzEnde+=deltatime/1000;



			let pc=1;
			if (sequenzEnde<sequenzEndeDauer){
				pc=sequenzEnde/sequenzEndeDauer;
			}
			
			let tbw = sequenzWrapSpalten+6;
			let tbh = sichtbarerTextlinien+4;
			let oldtbw=tbw;
			let oldtbh=tbh;

			tbw = (Math.floor(tbw*(1-pc*3)));
			tbh = (Math.floor(tbh*(1-pc*3)));
			let tby = 4+Math.floor((oldtbh-tbh)/2);//Math.floor((ch-tbh)/2);
			let tbx = Math.floor((cw-tbw)/2);
			drawBox(tbx,tby,tbw,tbh,8);

			if (sequenzEnde>=sequenzEndeDauer){		

				if (level>=leveldats[spracheIndex()].length){
					level=0;
					setGameState("TITEL");
					return;
				} else {		
					setGameState("SPIEL");
					return;
				}
			}
		} else {
			let tbw = sequenzWrapSpalten+6;
			let tbh = sichtbarerTextlinien+4;
			let tby = 4;//Math.floor((ch-tbh)/2);
			let tbx = Math.floor((cw-tbw)/2);
				//bottom soll 8 sein

			tby=Math.max(8-tbh+1,0)	;

			if (sichtbarerText.length>0){
				drawBox(tbx,tby,tbw,tbh,8);

				printText(sichtbarerText.substring(0,sichtbareBuchstaben),tbx+2,tby+2,8);
			}

			if (sichtbareBuchstaben<sichtbarerText.length){
				sichtbareBuchstaben++;
				playSound(1+(sichtbareBuchstaben%2),0.1);
				while(sichtbareBuchstaben<sichtbarerText.length && !isLetter(sichtbarerText[sichtbareBuchstaben])){
					sichtbareBuchstaben++;
				}
			}
		}

		if (zeigsequenzwort){

			let bx = 10;
			let by = 17;
			if (wort.length<6){
				bx=15;
			}
			if (wort.length>9){
				bx=5;
			}

			let bw = cw-bx-bx+1;
			let bh = 3;
			drawBox(bx,by,bw,bh,4);

			let tx=  bx+1+1;
			let ty = by+1;
			let tw = bw-2-2;


			let letterDist=2;
			let wortWidth=wort.length+(wort.length-1)*letterDist;
			while (wortWidth<=tw-4 ){
				letterDist+=2;
				wortWidth=wort.length+(wort.length-1)*letterDist;
			}
			
			letterDist-=2;
			wortWidth=wort.length+(wort.length-1)*letterDist;

			let wl = tx+Math.floor((tw-wortWidth)/2);


			let base_cursorX=wl+cursorPos*(letterDist+1)+Math.floor(letterDist/2);
			let cursorX=base_cursorX;


			let wortCol = 8;

			for (let i=0;i<wort.length;i++)
			{
				if (tauschanimation<tauschanimationdauer){
					if (i===cursorPos||i===cursorPos+1){
						continue;
					}
				}
				letterbuffer[wl+i*(letterDist+1)][ty]=wort[i];
				colorbuffer[wl+i*(letterDist+1)][ty]=wortCol;		
			}
		}

		for (let i=0;i<cw;i++){
			colorbuffer[i][ch]=11;
			letterbuffer[i][ch]=" ";
		}
		printText(
			S(
				`Entdeckungsreise :  Vorspiel zu Level ${level+1} (von ${leveldats[0].length}).`,
				`Galactic Center for Etymological Research : Prelude to level ${level+1} (of ${leveldats[0].length}).`
			),
			1,ch,
			11);
	}


	function renderTiteloberfläche(){

		let topmargin=4;

		let part2 = exitanim<exitanimdauer && exitanim*2>=exitanimdauer;
		if (part2){
			let p = Math.floor(2*(exitanim/exitanimdauer-0.5)*(ch));
			topmargin+=p;
		}
		let paddingx=4;
		let paddingy=1;
		let titel = S("Galaktisches Etymologieforschungs- institut","Galactic Center for Etymological Research");

		let bw = 18+2+4+2;//titel.length+2*paddingx+2;


		titel = wordwrap(titel,bw-2);

		let bh = 1+paddingy*2+2;

		let zx = cw/2;
		let zy = cw/2;

		let tb_x = Math.floor(zx-bw/2);
		let tb_y = topmargin+1;

		drawBox(tb_x,tb_y,bw,bh,4);
		// printRainbowText(titel,tb_x+1+paddingx,tb_y+1+paddingy,4,20)
		printText(titel,tb_x+2,tb_y+1,8)

		//optionen
		//new game
		//continue game (wo möglich)
		//sprache
		let optionenzahl=getVal("level"+sprache,0)===0?3:4;

		let optionen = [
			S("Spiel starten","Start Game"),
			S("Spiel fortsetzen	","Resume Game"),
			audio==="1" 
				? S("Audio : ein","Audio : on")
				: S("Audio : aus","Audio : off"),
			S("Sprache : Deutsch","Language : English")
		]
		if (optionenzahl===3){
			optionen.splice(1,1);
		}

		if (startcursorIndex>=optionenzahl){
			startcursorIndex--;
		}
		let menü_padding_y=0;

		let menü_w=18+2+4;
		let menü_h=optionen.length+4;
		
		let menü_x = Math.floor(zx-menü_w/2);
		let menü_y = tb_y+bh-1+menü_padding_y;

		drawBox(menü_x-1,menü_y,menü_w+2,menü_h,4);
		for (let i=0;i<optionen.length;i++){
			let tx = menü_x+1+2;
			let ty = menü_y+2+i;
			let t = optionen[i];
			if (startcursorIndex===i){
				if (exitanim<exitanimdauer){
					printRainbowText(t,tx,ty,2,30)

					let rots = ["|","/","-","\\"];
					let frame = Math.floor(rots.length*time/(0.5*1000))%rots.length;

					let char = rots[frame];
					letterbuffer[tx-2][ty]=char;
					colorbuffer[tx-2][ty]=8;
					letterbuffer[tx-1+menü_w-4][ty]=char;
					colorbuffer[tx-1+menü_w-4][ty]=8;

				} else {
					printText(t,tx,ty,8)
					letterbuffer[tx-2][ty]="[";
					colorbuffer[tx-2][ty]=8;
					letterbuffer[tx-1+menü_w-4][ty]="]";
					colorbuffer[tx-1+menü_w-4][ty]=8;
				}
			} else {
				if (exitanim>=exitanimdauer){
					printText(t,tx,ty,6)
				} else {
					printText(t,tx,ty,4)					
				}
			}
		}

		let cbox_h=3;
		let cbox_w=40;
		let cbox_x=Math.floor(cw/2-cbox_w/2);
		let cbox_y=ch-3;


		drawBox(cbox_x,cbox_y,cbox_w,cbox_h,4);
		printText(S("Steuerung: Pfeiltasten + X","Controls: Arrow keys + X"),
			cbox_x+2,cbox_y+1,4	)
					
		for (let i=0;i<cw;i++){
			colorbuffer[i][ch]=11;
			letterbuffer[i][ch]=" ";
		}
		printText(
			S(
				"GEFI v1.0 von increpare (analytic@gmail.com)",
				"CERG v1.0 by increpare (analytic@gmail.com)")
			,1,ch,11);

		// drawBox(0,0,cbox_x,cbox_y,3);

	}

	function centerStringOffset(s,w){
		let l = s.length;
		let lpadding = Math.floor((w-s.length)/2);
		return lpadding;
	}

	function centerString(s,w){
		let l = s.length;
		let lpadding = Math.floor((w-s.length)/2);
		let rpadding = w-(s.length+lpadding);
		return s.padStart(l+lpadding," ").padEnd(w," ");
	}

	let entdeckungmax=4;
	let entdeckung=2;

	let recovering=false;
	let outoffuel=false;
	function renderSpieloberfläche(){

		let fuelkisteheight=2+fuelcapacity;

		let fuelkistetop=1;//fuelkistebottom-fuelkisteheight+1;
		let fuelkistebottom = fuelkistetop+fuelkisteheight-1;

		//offset anim
		let segmentheight=Math.max(fuelkistebottom,2+entdeckungmax);
		//should go from -segmentheight to 0
		let frameprogress=segmentheight-Math.min(spielticker,segmentheight);

		//fuel
		drawBox(0,fuelkistetop-frameprogress,3,fuelkisteheight,0);
		printText(S("Treibstoff","fuel"),0,0-frameprogress,3)

		for (let i=0;i<fuelamount;i++){
			let ypos= fuelkistebottom-1-i;
			ypos-=frameprogress;
			if (ypos>0){
				letterbuffer[1][ypos]="=";
				colorbuffer[1][ypos]=9;
			}
		}

		//discovery


		let entdeckungkistebottom = ch-2;
		let entdeckungkisteheight=2+entdeckungmax;

		let entdeckungkistetop=entdeckungkistebottom-entdeckungkisteheight+1;



		let dbox_w=wort.length+2;
		let dbox_h=entdeckungmax+2;
		let dbox_x=cw-1-dbox_w;
		let dbox_y=1;
		drawBox(dbox_x,dbox_y-frameprogress,dbox_w,dbox_h,5);

		for (let i=0;i<entdeckung;i++){
			let w = visitedlist[i];
			let d_col = w===wort?10:2;
			printText(w,dbox_x+1,dbox_y+1+i-frameprogress,d_col)
		}

		let dtext = S("Entdeckung","discovery")
		printText(dtext,cw-dtext.length-1,0-frameprogress,3)


		if (wonlevel){

			let hbox_y=0;
			let hbox_w=40;
			let hbox_h=5;
			let hbox_x=Math.floor((cw-hbox_w)/2);

			drawBox(
					hbox_x,hbox_y,
					hbox_w,hbox_h,
					7);

			printText(
					centerString(
						S("Alles entdeckt!","Everything discovered!"),
						hbox_w-2
					),
					hbox_x+1,
					hbox_y+1,
					1
				);

			if (flyawayanim>=flyawayanimdauer){
				printText(
						centerString(
							S("Drucken Sie x um weiter zu fahren","Press X to continue"),
							hbox_w-2
						),
						hbox_x+1,
						hbox_y+3,
						1
					);
			}
			
		}

		if (fuelreward)
		{			

			let hbox_y=0;
			let hbox_w=40;
			let hbox_h=7;
			let hbox_x=Math.floor((cw-hbox_w)/2);

			drawBox(
					hbox_x,hbox_y,
					hbox_w,hbox_h,
					8);

			printText(
					centerString(
						S("Treibstofftankupgrade","Fuel Tank Upgrade"),
						hbox_w-2
					),
					hbox_x+1,
					hbox_y+1,
					8
				);
			
			printText(
					wordwrap(
						S(
							`Die Kapazität Ihres Treibstofftank wurde von ${cap_pre} auf ${cap_post} erhöhrt!`,
							`Your tank capacity has been increased from ${cap_pre} to ${cap_post}!`
						),
						hbox_w-2
					),
					hbox_x+1,
					hbox_y+2,
					8
				);


			printText(
					centerString(
						S("Drucken Sie x um weiter zu fahren","Press X to continue"),
						hbox_w-2
					),
					hbox_x+1,
					hbox_y+hbox_h-2,
					1
				);
		}

		if (outoffuel)
		{
			
			let zeichen_w=getStrW(keintreibstoff_zeichen[0]);
			let zeichen_h=getStrH(keintreibstoff_zeichen[0]);
			let zeichen_x=Math.floor((cw-zeichen_w)/2);
			let zeichen_y=1;

			blit(keintreibstoff_zeichen,zeichen_x,zeichen_y,0);


			let hbox_y=zeichen_h+1;
			let hbox_w=40;
			let hbox_h=4;
			let hbox_x=Math.floor((cw-hbox_w)/2);

			drawBox(
					hbox_x,hbox_y,
					hbox_w,hbox_h,
					7);

			printText(
					centerString(
						S("Treibstoff ausgegangen!","Out of fuel!"),
						hbox_w-2
					),
					hbox_x+1,
					hbox_y+1,
					1
				);
			
			printText(
					centerString(
						S("Drucken Sie H, um hilfen zu bitten","Press H to call for help"),
						hbox_w-2
					),
					hbox_x+1,
					hbox_y+2,
					1
				);
		}



		if (words.indexOf(wort)>=0&&fuelamount<fuelcapacity && tauschanimation>=tauschanimationdauer){
			refuelingdauer=0;
		}

		if (refuelingdauer<refuelingdauermax)
		{
					
			let hbox_y=-1;
			let hbox_w=40;
			let hbox_h=3;
			let hbox_x=Math.floor((cw-hbox_w)/2);

			// drawBox(
			// 		hbox_x,hbox_y,
			// 		hbox_w,hbox_h,
			// 		0);

			if (Math.floor(refuelingdauer*refuelingdauerblinkrate)%2===0){
				let s = S("Auftanken...","Refueling");
				let offset_x=centerStringOffset(s,hbox_w-2);
				printText(
						s,
						hbox_x+1+offset_x,
						hbox_y+1,
						9
					);
			}
			
		}


		let bx = 10;
		let by = 17-Math.min(spielticker,3);
		if (wort.length<6){
			bx=15;
		}
		if (wort.length>9){
			bx=5;
		}

		let bw = cw-bx-bx+1;
		let bh = 3;

		printText(S("Kompass","compass"),bx+1,by+3,3)

		let tx=  bx+1+1;
		let ty = by+1;
		let tw = bw-2-2;


		let letterDist=2;
		let wortWidth=wort.length+(wort.length-1)*letterDist;
		while (wortWidth<=tw-4 ){
			letterDist+=2;
			wortWidth=wort.length+(wort.length-1)*letterDist;
		}
		
		letterDist-=2;
		wortWidth=wort.length+(wort.length-1)*letterDist;

		let wl = tx+Math.floor((tw-wortWidth)/2);


		let base_cursorX=wl+cursorPos*(letterDist+1)+Math.floor(letterDist/2);
		let cursorX=base_cursorX;

		let raumschiffbild_index=0;
		let schiff_offset=0;
		// if (bewegunganimation<bewegunganimationdauer){
		// 	let pc = bewegunganimation/bewegunganimationdauer;
		// 	raumschiffbild_index= 1+Math.floor(pc*3);
		// 	// pc = raumschiffbild_index/5;
		// 	if (lastCursorPos>cursorPos){
		// 		raumschiffbild_index=4-raumschiffbild_index;
		// 		schiff_offset=1+Math.floor((letterDist-1)*(1-pc));
		// 		cursorX+=schiff_offset;
		// 	} else {
		// 		schiff_offset=1+Math.floor((letterDist)*(pc-1))-1;
		// 		cursorX+=schiff_offset;
		// 	}
		// } 

		let wortCol = (words.indexOf(wort)>=0) ? 8 :6;
		if (wortCol===8){
			lastgoodword=wort;
		}

		if (tauschanimation<tauschanimationdauer){
			wortCol=6;
			let pc = tauschanimation/tauschanimationdauer;
		 	raumschiffbild_index= 1+Math.floor(pc*3);
			if (lastCursorPos>cursorPos){
				raumschiffbild_index=4-raumschiffbild_index;
			} else {
			}
		} 
		if (endanim<endanimdauer){
			drawBox(bx,by,bw,bh,8);
		} else {
			drawBox(bx,by,bw,bh,4);			
		}

		if (wortCol===8){
			if (fuelamount<fuelcapacity){
				fuelamount++;
			}
		}

		if (wonlevel===false){
			letterbuffer[cursorX][ty]="&lt;";// ↔︎⟳
			colorbuffer[cursorX][ty]=6;		
			letterbuffer[cursorX+1][ty]="&gt;";
			colorbuffer[cursorX+1][ty]=6;	
		}


		for (let i=0;i<wort.length;i++)
		{
			if (tauschanimation<tauschanimationdauer){
				if (i===cursorPos||i===cursorPos+1){
					continue;
				}
			}
			letterbuffer[wl+i*(letterDist+1)][ty]=wort[i];
			colorbuffer[wl+i*(letterDist+1)][ty]=wortCol;		
		}

		if (tauschanimation<tauschanimationdauer){
			let pc = tauschanimation/tauschanimationdauer;
			let x1 = wl+cursorPos*(letterDist+1);
			let x2 = wl+(cursorPos+1)*(letterDist+1);
			let y = ty;
			let mx = (x2+x1)/2;
			let r = x2-mx;
			//pc=0 -> 0 grad
			//pc=1 -> 180 grad

			let dx1 = -r*Math.cos(-pc*Math.PI);
			let dy1 = -r*Math.sin(-pc*Math.PI);

			let dx2 = -r*Math.cos(-(1+pc)*Math.PI);
			let dy2 = -r*Math.sin(-(1+pc)*Math.PI)/2;

			if (dy1>1){
				dy1=1;
			}
			if (dy2<-1){
				dy2=-1;
			}

			let nx1 = Math.round(mx+dx1);
			let ny1 = Math.round(ty+dy1);

			let nx2 = Math.round(mx+dx2);
			let ny2 = Math.round(ty+dy2);

			letterbuffer[nx1][ny1]=wort[cursorPos+1];
			colorbuffer[nx1][ny1]=6;
			letterbuffer[nx2][ny2]=wort[cursorPos];
			colorbuffer[nx2][ny2]=6;
		}


		// letterbuffer[cursorX+2][ty]=">";
		// colorbuffer[cursorX+2][ty]=6;		

		// let raumschiffbild_index=1;

		// let raumschiffbild_index = Math.floor(raumschiff_bilder.length*time/(1*1000))%raumschiff_bilder.length;


		// if (cursorPos<cursorPos_Base){
		// 	raumschiffbild_index=0;
		// } else if (cursorPos>cursorPos_Base){
		// 	raumschiffbild_index=2;
		// }
		if (fuelamount===0 && tauschanimation>=tauschanimationdauer){
			raumschiffbild_index=4;
		}

		let raumschiffbild=raumschiff_bilder[raumschiffbild_index]


		if (flyawayanim<flyawayanimdauer){
			let from_x = base_cursorX+raumschiffbild[0]+schiff_offset;
			let from_y = ty+2;

			let to_x = from_x;
			let to_y = 0-2*getStrH(raumschiffbild[1][0]);



			let pc = flyawayanim/flyawayanimdauer;

			raumschiffbild_index = 0;// Math.floor(pc*20)%4;
			raumschiffbild=raumschiff_bilder[raumschiffbild_index]

			pc=Math.pow(pc,1.5);
			
			
			let cur_x=from_x;
			let cur_y = Math.floor((1-pc)*from_y+pc*to_y);

			blit(raumschiffbild[1],cur_x,cur_y,-10);

		} else if (recovering===false){
			blit(raumschiffbild[1],base_cursorX+raumschiffbild[0]+schiff_offset,ty+2,-1);
		}

		let letterspacing=Math.floor(tw/wort.length)-1;
		let zentrum = cw;


		if (recovering===true)
		{


			let hbox_y=3;
			let hbox_w=cw-5;
			let hbox_h=ch-5;
			let hbox_x=3;

			drawBox(
					hbox_x,hbox_y,
					hbox_w,hbox_h,
					7);

			let abschleppwagen_w=getStrW(abschleppwagen[0]);
			let abschleppwagen_h=getStrH(abschleppwagen[0]);
			let abschleppwagen_x=Math.floor((cw-abschleppwagen_w)/2);
			let abschleppwagen_y=Math.floor((ch-abschleppwagen_h)/2)-2;

			blit(abschleppwagen,abschleppwagen_x,abschleppwagen_y,-1);

			let text_y=abschleppwagen_y+abschleppwagen_h+1;

			printText(
					centerString(
						S("Rückführung des Fahrzeuges im Gange","Recovering vehicle"),
						hbox_w-2
					),
					hbox_x+1,
					text_y
				);
			
			let dotx = Math.floor((cw-recoverymax)/2)
			printText(
					"".padStart(recoverytimer,".").padEnd(recoverymax," "),
					dotx,
					text_y+2
				);

		}


		for (let i=0;i<cw;i++){
			colorbuffer[i][ch]=11;
			letterbuffer[i][ch]=" ";
		}

		if (level>=leveldats[spracheIndex()].length){
			
			printText(
				S(
					`Entdeckungsreise : Nachspiel`,
					`Voyage of Discovery : Postlude`
				),
				1,ch,
				11);
		} else {
			printText(
				S(
					`Entdeckungsreise : Level ${level+1} von ${leveldats[0].length}.`,
					`Voyage of Discovery : Level ${level+1} of ${leveldats[0].length}.`
				),
				1,ch,
				11);
		}

		// drawBox(0,0,cbox_x,cbox_y,3);

	}


	function render(){
		clearBuffer();

		let cx = Math.floor(cw/2);
		let cy = Math.floor(ch/2);


		// let frame = Math.floor(planet_anim.length*time/(3*1000))%planet_anim.length;
		// blit(planet_anim[frame],cx-4,cy-4,1);

		let selectionIndex=words.indexOf(wort);
		for (let i=0;i<planeten.length;i++){	
			let planet = planeten[i];
			let highlight = gameState ==="SPIEL" && selectionIndex===i && tauschanimation>=tauschanimationdauer;
			drawSprite(planet,highlight);
		}

		for (let i=0;i<sterne.length;i++){			
			let coord = sterne[i];
				
			let s = CoordToScreenSpace(coord);

			let d = s[0];
			let sx=s[1][0];
			let sy=s[1][1];

			sx+=cx;
			sy+=cy;
			if (gameState==="SEQUENZ"){
				// sx=cx+Math.floor(sx/2);
				// sy=cy+Math.floor(sy/2);
				d*=2;
			}			
			if (sx>=cw || sy>=ch || sx<0 || sy<0){
				continue;
			}

			if (d<depthbuffer[sx][sy]){
				if (gameState==="SPIEL"){
					letterbuffer[sx][sy]=".";
				} else {
					if (d>1.2){			
						letterbuffer[sx][sy]=".";
					} else if (d>0.8){
						letterbuffer[sx][sy]="o";
					} else {
						letterbuffer[sx][sy]="O";				
					}
				}
				let col;
				if (d>1.5){
					col=3;
				} else if (d>0.2){
					col=3;
				} else {
					col=2;
				}
				colorbuffer[sx][sy]=col;
				depthbuffer[sx][sy]=d;
			}
		}

		switch(gameState){
			case "TITEL":
				renderTiteloberfläche();
				break;
			case "SEQUENZ":
				renderSequenzoberfläche();
				break;
			case "SPIEL":
				renderSpieloberfläche();
				break;
		}

		flipBuffer();
	}

	let targetstate="";
	function setGameState(newgs){
		targetstate=newgs;
	}

	function startTitleBildschirm(){
		words = titelwords;
		setDimensionen(words[0].length-1);
		generateWordPerms();

		
		spawnTitelPlaneten();

		
		render();
	}

	function rot(p,i_axis,j_axis,theta){
		if (j_axis>=dimensionen){
			j_axis=dimensionen-1;
		}
		let pi = p[i_axis];
		let pj = p[j_axis];
		let ct = Math.cos(theta);
		let st = Math.sin(theta);

		p[i_axis] = pi*ct-pj*st;
		p[j_axis] = pi*st+pj*ct;
	}

	let time=0;

	let tauschanimationdauer=0.6;
	let tauschanimation=tauschanimationdauer;

	let bewegunganimationdauer=0.5;
	let bewegunganimation=bewegunganimationdauer;


	function titelTick(){
		if (exitanim<exitanimdauer){
			exitanim+=deltatime/1000;
			if (exitanim>=exitanimdauer){
				setGameState("SEQUENZ");
			}
		}


		let theta = 2*Math.PI*deltatime/(12*1000);

		

		for (let i=0;i<sterne.length;i++){
			let s = sterne[i];
			if (tauschanimation<tauschanimationdauer){
				for (let j=0;j<dimensionen;j++){
					rot(s,j,2,-3*theta/(j+1));
				}
			}
		}

		if (exitanim<exitanimdauer)
		{
			campos[2]-=3*theta;
		} else {

			for (let i=0;i<planeten.length;i++){
				let planet = planeten[i];

				if (dimensionen>2)
				{
					for (let j=0;j<dimensionen;j++){
						if (j===2){
							continue;
						}
						rot(planet[0],j,2,-theta/(j+1));
					}
				} else {
					rot(planet[0],0,1,-theta);
				}
			}
		}
	}


	let lastgoodword="";
	let recoverytimer=0;
	let recoverymax=30;

	let wonlevel=false;

	let endanimdauer=0.3;
	let endanim=endanimdauer;

	let flyawayanimdauer=1.5;
	let flyawayanim=flyawayanimdauer;

	function startEnd(){
		playSound(4);
		endanim=0;
	}

	let fuelreward=0;
	let cap_pre=0;
	let cap_post=0;

	function doGiveReward(am){
		cap_pre = fuelcapacity;
		fuelcapacity+=am;
		cap_post = fuelcapacity; 
		fuelreward=true;
	}

	let spielticker=0;

	function spielTick(){
		spielticker++;
		if (refuelingdauer<refuelingdauermax){
			refuelingdauer+=deltatime/1000;
		}

		if (flyawayanim<flyawayanimdauer){
			flyawayanim+=deltatime/1000;
			if (flyawayanim>=flyawayanimdauer){
				flyawayanim-=deltatime/1000;
				level++;
				setVal("level"+sprache,level);
				setGameState("SEQUENZ");
			}
		}

		if (recovering){
			recoverytimer+=2;
			if (recoverytimer>recoverymax){
				recovering=false;
				// outoffuel=false;
				wort = lastgoodword;				
			}
		}

		if (endanim<endanimdauer){
			endanim+=deltatime/1000;
			if (endanim>=endanimdauer){
				wonlevel=true;
			}
		}

		if (tauschanimation<tauschanimationdauer){
			tauschanimation+=deltatime/1000;
			if (tauschanimation>=tauschanimationdauer){
				if (fuelamount===0 && words.indexOf(wort)===-1){
					if (!outoffuel){
						playSound(11);
						outoffuel=true;
					}
				}
				if (words.indexOf(wort)>=0 && visitedlist.indexOf(wort)===-1){
					visitedlist.push(wort);
					playSound(6);
					if (rewards[wort]>0){
						doGiveReward(rewards[wort]);
					}
					entdeckung++;
					if (entdeckung===entdeckungmax){
						startEnd();
					}
				}
			}
		}

		bewegunganimation+=deltatime/1000;

		let theta = 2*Math.PI*deltatime/(12*1000);
		for (let i=0;i<sterne.length;i++){
			let s = sterne[i];
			if (tauschanimation<tauschanimationdauer){
				for (let j=0;j<dimensionen;j++){
					// rot(s,j,2,-3*theta/(j+1));
				}
			}
		}

		for (let i=0;i<planeten.length;i++){
			let planet = planeten[i];
			if (tauschanimation<tauschanimationdauer){
				for (let j=0;j<dimensionen;j++){
					// rot(planet[0],j,2,-5*theta/(j+1));
				}
			}
			if (dimensionen>2)
			{
				for (let j=0;j<dimensionen;j++){
					if (j===2){
						continue;
					}
					// rot(planet[0],j,2,-theta/(j+1));
				}
			} else {
				// rot(planet[0],0,1,-theta);
			}
		}
		setGameCamPos(false);


	}

	function sequenzTick(){
		let theta = 2*Math.PI*deltatime/(12*1000);
		for (let i=0;i<sterne.length;i++){
			let s = sterne[i];
			rot(s,0,2,-0.15*theta);
		}

	}

	function tick(){
		time+=deltatime;

		switch (gameState){
			case "TITEL":
				titelTick();
				break;
			case "SEQUENZ":
				sequenzTick();
				break;
			case "SPIEL":
				spielTick();
				break;
		}

		render();

		if (targetstate!==""){
			gameState=targetstate;
			targetstate="";
			switch(gameState){
				case "TITEL":
					startTitleBildschirm();
				break;
				case "SEQUENZ":
					startSequenz();
					break;
				case "SPIEL":
					startSpiel();
					break;
				break;
			}
			tick();
		}
	}

	let sequenzindex=0;
	let sequenzEndeDauer=1.0;
	let sequenzEnde=0;

	function startSequenz(){
		sequenzEnde=sequenzEndeDauer;
		sichtbarerText="";
		sichtbareBuchstaben=0;
		zeigsequenzwort=false;
		setDimensionen(3)


		planeten=[];

		let my_planet_anim = genAllFrames(
				0,
				5,//blue
				6//green
				);
		let planetframes = [my_planet_anim[7]];
		planetframes[0][0]=100;
		let planet = [ origin.slice(), planetframes];
		planeten.push(planet);

		sterne=[];

		while(sterne.length<15){
			let stern = [];
			for (let j=0;j<dimensionen;j++){
				stern.push((Math.random()-0.5)*1.0);
			}
			let d = dist(stern,origin);
			if (d>0.5 && d<1.0)
			{
				sterne.push(stern);
			}
		}

		
		sequenzindex=-1;
		sequenzSchritt();	

		if (level>=leveldats[spracheIndex()].length){
			playSound(12);
		}	
	}

	function setGameCamPos(reset_cam_dir){
		let wortindex = words.indexOf(wort);
		let wordpos = permToVec(wordToPerm(baseword, wort));
		let camDist=1;
		let wordpos_len = vectLen(wordpos);

		let camback = normalizedVect(wordpos);

		let reset_cam_pos = tauschanimation>=tauschanimationdauer;
		// reset_cam_pos=true;		
		// reset_cam_dirt=true;

		// jumpcampos=true;
		let targetcampos = smul(wordpos_len+camDist,camback);	
		
		if (dimensionen===2){
			targetcampos=vectAdd(wordpos,[0,0,-1]);
		}

		// reset_cam_pos=true;
		// reset_cam_dir=true;

		if (reset_cam_pos){
			campos=targetcampos;
			// oldcampos=campos;
		} else {

			let pc = tauschanimation/tauschanimationdauer;
			campos = vectLerp(oldcampos,targetcampos,pc);	

			campos_l = vectLen(campos);
			oldcampos_l = vectLen(oldcampos);	
			targetcampos_l = vectLen(targetcampos);	
			let m = Math.min(oldcampos_l,targetcampos_l);
			let current_l  = (1-pc)*oldcampos_l+pc*targetcampos_l;
			campos = smul(current_l/campos_l,campos);

		}
			

		camforward = smul(-1,campos)

		if (reset_cam_dir){
			//camup, normal to camforward
			//https://math.stackexchange.com/questions/133177/finding-a-unit-vector-perpendicular-to-another-vector
			camup = origin.slice();
			let n =0;
			let m = 0;
			for (m=0;m<camup.length;m++){
				if (Math.abs(camforward[m])>0.001){
					n=0;
					if (m===0){
						n=1;
					}
					camup[n]=camforward[m];
					camup[m]=-camforward[n];
					break;
				}
			}
			camup = normalizedVect(camup);

			if (dimensionen>=3){
				let o=0;
				for(o=0;o<3;o++){
					if (o===m||o===n){
						//boo
					} else {
						break;
					}
				}
				//get the cross product in indices o, m, and n?
				if (dimensionen>2)
				{
					camright=highercross(camup,camforward,o,m,n);
				} else {
					camright=camup;
				}
			} else {
				camright=camforward;
			}
		} else 
		{
			//camup and cam right

			let preup = camup;
			

			let camup_residue = project(camup,camforward);
			camup = vectSub(camup,camup_residue);
			camup = normalizedVect(camup);


			
			let postup = camup;
			
			if (dimensionen>2){
				let camright_residue1 = project(camright,camforward);
				camright = vectSub(camright,camright_residue1);
				camright = normalizedVect(camright);

				let camright_residue2 = project(camright,camup);
				camright = vectSub(camright,camright_residue2);
				camright = normalizedVect(camright);
			} else {
				camright=camforward;
			}

		}

		if (dimensionen===2){
			camforward=[0,0,1];
			camright=[1,0,0];
			camup=[0,1,0];
		}
		// targetcampos = vectAdd(targetcampos,smul(0.2,camup));


		//camright

	} 

	function highercross(a,b,i1,i2,i3){
		let o = origin.slice();
		o[i1]=a[i2]*b[i3]-a[i3]*b[i2];
		o[i2]=a[i3]*b[i1]-a[i1]*b[i3];
		o[i3]=a[i1]*b[i2]-a[i2]*b[i1];
		return o;
	}

	function wordToPerm(grundwort,w){
		let p = [];
		for (let i=0;i<grundwort.length;i++){
			p.push(i);
		}

		for (let i=0;i<grundwort.length;i++){
			let c = grundwort[i];
			let cindex = w.indexOf(c);
			p[i] = cindex;
		}
		return p;
	}




	function wordToRPerm(grundwort,w){
		let p = [];
		for (let i=0;i<grundwort.length;i++){
			p.push(i);
		}

		for (let i=0;i<grundwort.length;i++){
			let c = grundwort[i];
			let cindex = w.indexOf(c);
			p[cindex] = i;
		}
		return p;
	}
	
	function startSpiel(){
		playSound(8);
		refuelingdauer=refuelingdauermax;
		spielticker=0;

		if (level===0){
			startcursorIndex=1;
		} else {
			startcursorIndex=0;
		}


		sterne=[]

		wonlevel=false;
		recovering=false;
		outoffuel=false;
		endanim=endanimdauer;			
		flyawayanim=flyawayanimdauer;

		let spracheindex = spracheIndex();

		//load level dat

		let curleveldat = leveldats[spracheindex][level];

		entdeckungmax = curleveldat.length;
		entdeckung=1;

		words=[];
		rewards={};
		visitedlist=[];

		for (let i=0;i<curleveldat.length;i++){
			let cld=curleveldat[i];
			let w = cld[0];
			let r = cld[1];
			words.push(w);
			rewards[w]=r;
		}
		wort=words[0];

		console.log(wort)
		console.log(rewards)
		fuelcapacity=rewards[wort];
		console.log("WORD "+wort+"\tREWARD "+fuelcapacity);
		fuelamount=0;

		visitedlist.push(wort);

		baseword = wort;

		generateWordPerms();
		
		setDimensionen(words[0].length-1)
		spawnTitelPlaneten();

		sterne=[]
		while(sterne.length<15){
			let stern = [];
			for (let j=0;j<dimensionen;j++){
				stern.push((Math.random()-0.5)*2.0);
			}
			let d = dist(stern,origin);
			// if (d>0.5 && d<1.0)
			{
				sterne.push(stern);
			}
		}

		// sterne=[origin]

		setGameCamPos(true);
	}

	let deltatime=100;

	let music_instance=null;
	function soundInit(){

		if (!createjs.Sound.initializeDefaultPlugins()) {
			document.getElementById("error").style.display = "block";
			document.getElementById("content").style.display = "none";
			return;
		}

		//examples.showDistractor("content");
		let assetsPath = "./audio/";
		let sounds = [
			{src: "blip1.mp3", id: 1},
			{src: "blip2.mp3", id: 2},
			{src: "select.mp3", id: 3},
			{src: "solved.mp3", id: 4},
			{src: "ambulance.mp3", id: 5},
			{src: "newfound.mp3", id: 6},
			{src: "exit.mp3", id: 7},
			{src: "rising.mp3", id: 8},//new
			{src: "falling.mp3", id: 9},
			{src: "risingbig.mp3", id: 10},
			{src: "fail.mp3", id: 11},
			{src: "gameover.mp3", id: 12},
		];

		// createjs.Sound.alternateExtensions = ["mp3"];	// add other extensions to try loading if the src file extension is not supported

		// createjs.Sound.addEventListener("fileload", createjs.proxy(soundLoaded, this)); // add an event listener for when load is completed
		createjs.Sound.registerSounds(sounds, assetsPath);


		 let loadHandler = function(event) {
		 	if (event.src.indexOf("bgmusic")===-1){
		 		return;
		 	}

		     // This is fired for each sound that is registered.
		     let instance = createjs.Sound.play("bgmusic",{loop:-1});  // play using id.  Could also use full source path or event.src.
		     instance.on("complete", this.handleComplete, this);
		     instance.volume = 0.5;
		 }

		// createjs.Sound.on("fileload", loadHandler, this);
		// createjs.Sound.registerSound("./audio/bgmusic.mp3", "bgmusic");

		 
		let a = createjs.Sound.play(13);
		a.volume=0.2;


	}

	function globalSetup(){
		soundInit();

		setDimensionen(words[0].length-1)

		setInterval(tick, deltatime);

		document.onkeydown = checkKey;	
		document.onkeyup = onKeyup;	
		document.onfocus = onFocus;	

		createBuffer();		

		// setGameState("SPIEL")
		setGameState("TITEL")
		// setGameState("SEQUENZ");

		handleresize();
	}

	window.onload =globalSetup;
	window.onresize = handleresize;
</script>
</body>
</html>