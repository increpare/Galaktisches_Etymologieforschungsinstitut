<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8">

	<title>Explore the Universe</title>


	<style>	
		body{
			background-color: black;
			width: 100%;
			margin:0;
			text-align: center;
		}
  


		#console {
		    /*width: 630px;*/
		    padding: 0;
		    font-family: "Lucida Console", Monaco, monospace;
    		white-space: pre;
    		/*font-size: 1.6vw;*/
    		margin: :0;
    		font-size: 2.4vh;	
    		/*font-size: calc(min(1.6vw,2.4vh));	*/
    		/*line-height: 1;*/
			color:white;
		}
		.col1 {
			color:white;
			background-color: black;
		}
		.col2 {
			color:gray;
			background-color: black;
		}
		.col3 {
			color:darkgray;
			background-color: black;
		}
		.col4 {
			color:darkgreen;
			background-color: black;
		}
		.col5 {
			color:blue;
			background-color: black;
		}
		.col6 {
			color:green;
			background-color: black;
		}
		.col7 {
			color:red;
			background-color: black;
		}
		.col8 {
			color:yellow;
			background-color: black;
		}
		.col9 {
			color:fuchsia;
			background-color: black;
		}
		.col0 {
			color:purple;
			background-color: black;
		}
		.col10 {
			color:lightblue;
			background-color: black;
		}
		u {			
			/*font-weight: bold;*/
			background-color: black;
		}
	</style>

</head>

<body>

<div id="console">
	Loading game (requires javascript)
</div>
<script>

//from https://jsfiddle.net/Dwaaren/j9zahaLL/
	function vwTOpx(value) {
    var w = window,
      d = document,
      e = d.documentElement,
      g = d.getElementsByTagName('body')[0],
      x = w.innerWidth || e.clientWidth || g.clientWidth,
      y = w.innerHeight|| e.clientHeight|| g.clientHeight;

    var result = (x*value)/100;
    return result;
  }

  function vhTOpx(value) {
    var w = window,
      d = document,
      e = d.documentElement,
      g = d.getElementsByTagName('body')[0],
      x = w.innerWidth || e.clientWidth || g.clientWidth,
      y = w.innerHeight|| e.clientHeight|| g.clientHeight;

    var result = (y*value)/100;
    return result;
  }

 //end borrow

function handleresize(){
	//calc(min(1.6vw,2.4vh));
	var vw=1.6;
	var vh=3.0;
	let px_16vw = vwTOpx(vw);
	let px_24vh = vhTOpx(vh);

	console.log(px_16vw,px_24vh);
	let textbox = document.getElementById("console");

	if (px_16vw<px_24vh){
		textbox.style.fontSize=vw+"vw";
	} else {
		textbox.style.fontSize=vh+"vh";
	}
}

let Planet_Eingeweide = [  
[
"                ",
"   /  \\        ",
"  |  _|        ",
"  |_/   _/\\___ ",
"       /      \\"
],
[
"                ",
" |     _/  \\_/ ",
" \\   _|   _    ",
"  |_/   _/ \\_/\\",
"       /      |"
],
[
"                ",
" /  /  /  /  /  ",
"/  /  /  /  /  /",
"  /  /  /  /  / ",
" /  /  /  /  /  "
],
[
"                ",
"       _       _",
"\\_   _/ \\_   _/ ",
"  \\_/     \\_/   ",
"                "
],
[
"                ",
" _              ",
"/ \\      _       ",
"\\_/     / \\     ",
"        \\ /     "
],
[
"                ",
"|  |   |    |  ",
"    ---      --",
"   --     ---- ",
"  |  |   |    |",
],
[
"                ",
"       /  \\     ",
"   _ _/  _/    _",
"\\_/ X  _/  /\\_/ ",
"   / \\/   /     ",
],
[
"                ",
"  ,  ,   ,    , ",
",     ,    ,    ",
"   ,    ,    ,  ",
"                ",
],
[
"                ",
" | |   |   |    ",
" | |   |___|    ",
" |_|  __   ___  ",
"     |  | |   | ",
],
[
"                ",
"    /  _    \\   ",
"   |  / \\_   \\  ",
"  /  |    \\__|  ",
" |    \\         ",
],
[
"                ",
" /\\// __   _/\\  ",
"//\\/ /__\\_/_/\\\\_",
"/   //  \\_/   \\_",
"   ||           ",
]
];

let planet_cursor_highlight = [
` __      __ 
|          |
|          |
            
            
|          |
|__      __|`,
`888888888888
888888888888
888888888888
888888888888
888888888888
888888888888
888888888888`,
`.##......##.
#..........#
#..........#
............
............
#..........#
###......###`
]




let planet_umriss = [
"   __   ",
" /    \\ ",
"|      |",
"|      |",
" \\____/ "
];

let planet_maske = [
"        ",
"  oooo  ",
" oooooo ",
" oooooo ",
"  oooo  "
]


let planet_aussere_maske = 
`...##...
.######.
########
########
.######.`;



let planet_umriss_vvsm = 
` _ 
|_|`;

let planet_vvsm_aussere_maske = 
`.#.
###`;

let planet_umriss_vsm = 
` __ 
/  \\
\\__/`;

let planet_vsm_aussere_maske = 
`.##.
####
####`;

let planet_umriss_sm = 
`  ___  
 /   \\ 
|     |
 \\___/ `;

let planet_sm_aussere_maske = 
`..###..
.#####.
#######
.#####.`;

function fillRect(c,w,h){
	let r = "";
	for (let i=0;i<h;i++){
		for (let j=0;j<w;j++){
			r+=c;
		}
		if (i<h-1){
			r+="\n";
		}
	}
	return r;
}

function getStrW(s){
	return (s+"\n").indexOf("\n");
}
function getStrH(s){
	return (s.length+1)/(getStrW(s)+1)
}

function pickMipMap(anims,d){
	if (d>anims[0][0]){
		return null;
	}

	for (let i=1;i<anims.length-1;i++){
		let anim=anims[i];
		if (d>anim[0]){
			return anims[i-1];
		}
	}
	return anims[anims.length-1];
}

function genAllFrames(sourceLayout,waterIndex,landIndex){
	let anims=[
	//d,w,h,frames
		[100,0,0,[[" ",""+waterIndex,"#"]]],
		[7,0,0,[[".",""+waterIndex,"#"]]],
		[6,0,0,[["o",""+waterIndex,"#"]]],
		[5,0,0,[["O",""+waterIndex,"#"]]],
		[4,0,0,[[planet_umriss_vvsm,fillRect(waterIndex,3,2),planet_vvsm_aussere_maske]]],
		[3,0,0,[[planet_umriss_vsm,fillRect(waterIndex,4,3),planet_vsm_aussere_maske]]],
		[2,0,0,[[planet_umriss_sm,fillRect(waterIndex,7,4),planet_sm_aussere_maske]]],
		[1,0,0,genBigFrames(sourceLayout,waterIndex,landIndex)]
	];	
	for(let i=0;i<anims.length;i++){
		let anim = anims[i];
		let frame1 = anim[3][0][0];
		anim[1]=getStrW(frame1);
		anim[2]=getStrH(frame1);
	}
	return anims;
}

//color indices 5->9
function genBigFrames(sourceLayout,waterIndex,landIndex){
	let anim=[];
	let eingeweide = Planet_Eingeweide[sourceLayout];

	for (let i=0;i<15;i++){

		let planetkonturen="";
		let farbemaske="";

		for (let y=0;y<5;y++){
			for (let x=0;x<8;x++){
				let stringindex=x+8*y;
				let c = planet_umriss[y][x];
				let f = waterIndex;
				if (planet_maske[y][x]==="o")
				{
					let eingeweide_index = (8+x+i)%15;
					let egi = eingeweide[y][eingeweide_index];
					if (egi!==" ") {
						c = egi;
						f=landIndex;
					}
				}
				planetkonturen+=c;
				farbemaske+=f;
			}
			if (y<4){
				planetkonturen+="\n";
				farbemaske+="\n";
			}
		}

		let frame = [planetkonturen,farbemaske,planet_aussere_maske]
		anim.push(frame);
	}
	return anim;
}


let abschleppwagen = [
`                 _      
               /  |     
             / / |      
           / /   |     .
    ____ / / ____|___/_|
  /  |   | /           |
 |___|   | \\ __________|
|        |_________   \\|
|   __    _________|    
|_/    \\_|____/  \\_|    
   \\__/       \\__/      `,
`888888888888888888888888
888888888888888888888888
888888888888888881888888
888888888888888881888882
888888888888822221222222
882888888882888888888882
828888888882822222222222
888888888888888888888822
888888888888888888888888
888888888822222882228888
888333388888883333888888`,
`.................#......
...............####.....
.............#####......
...........#######.....#
....####################
..######################
.#######################
###################...##
####################....
####################....
...####......#####......`
];

let keintreibstoff_zeichen = [
`     _____     
   /       \\   
 /    __  \\  \\ 
|    |__|  |  |
|    |  |\\/   |
 \\   |__|    / 
   \\ _____ /   `,
`222222222222222
222222222222222
222222772272222
222227777227222
222227227772222
222227777222222
222222222222222`,
`     #####     
   #########   
 ############# 
###############
###############
 ############# 
   #########   `
];

let raumschiff_bilder = [	
	[
		-5,
		[
`     /\\    
    |  |   
    |  |   
    |  |   
   /|  |\\  
 /__|__|__\\
     vv    `,
`33333333333
33333333333
33333333333
33333333333
33333333333
33333333333
33333883333`,
`.....##....
....####...
....####...
....####...
...######..
.##########
.....##....`
		]
	],

	[
		-5,
		[
`     /\\    
    |  |   
    |  |   
    |  |   
    || |   
   /_|_|\\ 
     vv    `,
`33333333333
33333333333
33333333333
33333333333
33333333333
33333333333
33333883333`,
`.....##....
....####...
....####...
....####...
....####...
...######..
.....##....`
		]
	],

	[
		-5,
		[
`     /\\    
    |  |   
    |  |   
    |  |   
    | ||   
    |_||   
     vv    `,
`33333333333
33333333333
33333333333
33333333333
33333333333
33333333333
33333883333`,
`.....##....
....####...
....####...
....####...
....####...
....####...
.....##....`
		]
	],

	[
		-5,
		[
`     /\\    
    |  |   
    |  |   
    |  |   
    |  |   
   /|_|_\\  
     vv    `,
`33333333333
33333333333
33333333333
33333333333
33333333333
33333333333
33333883333`,
`.....##....
....####...
....####...
....####...
....####...
...######..
.....##....`
		]
	],

	[
		-5,
		[
`     /\\    
    |  |   
    |  |   
    |  |   
   /|  |\\  
 /__|__|__\\
           `,
`33333333333
33333333333
33333333333
33333333333
33333333333
33333333333
33333883333`,
`.....##....
....####...
....####...
....####...
...######..
.##########
...........`
		]
	],
]

let planet_anim = [
[//1
`   __
 /    \\
|    | |
|_   |_|
 \\\\__ /
`,
`   55
 566665
56666665
56666665
 565555
`
],
[//2
`   __
 /   /\\
|   |  |
|   |_/|
 \\___ /
`,
`   55
 566665
56666665
56666665
 555555
`
],
[//3
`   __
 /  / \\
|  |  _|
|  |_/ |
 \\___ /
`,
`   55
 566665
56666665
56666665
 555555
`
],
[//3b
`   __
 / /  \\
| |  _||
| |_/  |
 \\___ /
`,
`   55
 566665
56666665
56666665
 555555
`
],
[//4
`   __
 /   \\\\
||  _| |
||_/   |
 \\___ /
`,
`   55
 566665
56666665
56666665
 555555
`
],
[//5
`   __
 /  \\ \\
|  _|  |
|_/    |
 \\___//`,
`   55
 566665
56666665
56666665
 555565
`
],
[//6
`   __
 / \\  \\
| _|   |
|/    _|
 \\__/_/`,
`   55
 566665
56666665
56666665
 555655
`
],
[//7
`   __
 /\\   \\
|_|    |
|   _/\\|
 \\/__ /`,
`   55
 566665
56666665
56666665
 565555
`
],
[//8
`   __
 /    \\
||     |
| __/\\_|
 \\___ /
`,
`   55
 566665
56666665
56666665
 555555
`
],
[//9AAA
`   __
 /    \\
|      |
| _/\\__|
 \\___ /
`,
`   55
 566665
56666665
56666665
 555555
`
],
[//9AAA
`   __
 /    \\
|      |
| /\\__ |
 \\___ /
`,
`   55
 566665
56666665
56666665
 555555
`
],
[//10
`   __
 /    \\
|      |
|\\___  |
 \\___\\/
`,
`   55
 566665
56666665
56666665
 555565
`
],
[//11
`   __
 /    \\
|      |
|\\__   |
 \\__\\_/
`,
`   55
 566665
56666665
56666665
 555655
`
],
[//12
`   __
 /    \\
|     ||
|__   ||
 \\_\\_ /
`,
`   55
 566665
56666665
56666665
 556555
`
]

]

let leveldats =  [
	[//DEU	
		[//L1		
			["TOR",2],
			["ORT",0],
			["ROT",0],
		],
		[

			["EHRE",2],
			["REHE",0],
			["HEER",0],
			["EHER",0],
		],
		[//L2		
			["SEIEN",1],
			["SEINE",1],
			["EISEN",1],
			["EINES",0],
		],
		[//L3
			["REISEN",1],
			["RIESEN",2],
			["REINES",1],
			["SERIEN",0],
			["SIRENE",0],
			["SEINER",0],
			["EISERN",0],
			["EINSER",0],
		],
		[//L4
			["STREICHEN",5],
			["SCHEITERN",3],
			["SCHREITEN",3],
			["SICHERTEN",0],
			["REICHSTEN",0],
		],
		[//L5
			["EIFERN",2],
			["FERIEN",1],
			["FEIERN",0],
			["FREIEN",0],//KÖNNTE AUCH DAS PUNKTE GEBEN (STATT FERIEN)
			["RIEFEN",0],
			["REIFEN",0],
		],
	],
	[//eng
		[//l1
			["now",2],
			["own",0],
			["won",0]
		],
		[//l2
			["east",1],
			["eats",1],
			["seat",0],
			["sate",0],
			["teas",0],
		],
		[//l3
			["steak",2],
			["stake",1],
			["skate",1],
			["teak",0],
			["taxes",0]
		],
		[//l4
			["parse",1],
			["pares",1],
			["pears",1],
			["spare",1],
			["spear",1],
			["reaps",0],
		],
		[//l5
			["alerting",2],
			["alerting",4],
			["relating",6]
		],
	]
]
let wordLength=3;
let vis=[];

let titelwords = ["dcba","dcab","dbac","dbca","dabc","dacb","cdba","cdab","cbad","cbda","cabd","cacb","bcda","bcad","bdac","bdca","badc","bacd","acbd","acdb","abdc","abcd","adbc","adcb"]


let level=0;
let gameState="TITEL";

let words = titelwords;
let rewards=[];
let visitedlist=[];

// let words = ["12345","21345","31245","13245","23145","32145","32415","23415","43215","34215","24315","42315","41325","14325","34125","43125","13425","31425","21435","12435","42135","24135","14235","41235","51234","15234","25134","52134","12534","21534","21354","12354","32154","23154","13254","31254","35214","53214","23514","32514","52314","25314","15324","51324","31524","13524","53124","35124","45123","54123","14523","41523","51423","15423","15243","51243","21543","12543","52143","25143","24153","42153","12453","21453","41253","14253","54213","45213","25413","52413","42513","24513","34512","43512","53412","35412","45312","54312","54132","45132","15432","51432","41532","14532","13542","31542","51342","15342","35142","53142","43152","34152","14352","41352","31452","13452","23451","32451","42351","24351","34251","43251","43521","34521","54321","45321","35421","53421","52431","25431","45231","54231","24531","42531","32541","23541","53241","35241","25341","52341"]
// let words = ["apres", "asper", "pares", "parse", "pears", "spear", "spare", "rapes", "reaps", "apers"]
// let words = ["dcba","dcab","dbac","dbca","dabc","dacb","cdba","cdab","cbad","cbda","cabd","cacb","bcda","bcad","bdac","bdca","badc","bacd","acbd","acdb","abdc","abcd","adbc","adcb"]
// let words = ["bepis","ebpsi","bpeis"]
// let words = ["cba","cab","bac","bca","abc","acb"]

function permToStr(p){
	let r = "";
	for (let i=0;i<p.length;i++){
		r+=p[i].toString(16);
	}
	return r;
}

let perms = [];
let rperms = [];
let perms_str = [];
let rperms_str = [];

function generateWordPerms(){
	perms=[];
	rperms=[];
	perms_str = [];
	rperms_str = [];

	let base = words[0];
	for (let i=0;i<words.length;i++){
		let word = words[i];
		let perm=[];
		let rperm=[];
		for (let j=0;j<word.length;j++){
			let basechar = base[j];
			let wordchar = word[j];
			perm.push(word.indexOf(basechar));
			rperm.push(base.indexOf(wordchar));
		}
		perms.push(perm);
		rperms.push(rperm);

		perms_str.push(permToStr(perm));
		rperms_str.push(permToStr(rperm));
	}
}

let wort = "epbis";
let baseword = wort;
let cursorPos=1;
let lastCursorPos=cursorPos;
let cursorPos_Base=cursorPos;

function permToVec(p){
	// console.log (" p = "+p);
	let dim=p.length;
	let s =0;
	for (let i=0;i<p.length;i++){
		    s+=p[i];
	}	
	let v1 = p.slice();
	for (let i=0;i<v1.length;i++){
		v1[i]=(v1[i]);
	}
	// console.log (" v1 = "+v1);

	let v2 = [];
	for (let i=1;i<p.length;i++){
		v2.push(2*(p[i]-(dim-1)/2)/dim);
	}
	v2=normalizedVect(v2);
	v2=smul(0.7,v2)
	// console.log( "v2 = "+v2)
	while(v2.length<3){
		v2.push(v2.length);
	}
	return v2;
}


function vectSlerp(start,end,percent){
     // Dot product - the cosine of the angle between 2 vectors.
     let d = dot(start, end);     
     // Clamp it to be in the range of Acos()
     // This may be unnecessary, but floating point
     // precision can be a fickle mistress.
     if (d<-1){
     	d=-1;
     }
     if (d>1){
     	d=1;
     }

     let theta = Math.acos(d)*percent;
     relativeVec = vectSub(end ,smul(d,start));
     relativeVec = normalizedVect(relativeVec);
     return vectAdd( smul(Math.cos(theta),start) , smul(Math.sin(theta),relativeVec) );
}

function vectLerp(v1,v2,a){
	let r = [];
	for (let i=0;i<v1.length;i++){
		r.push((1-a)*v1[i]+a*v2[i]);
	}
	return r;
}

function vectAdd(v1,v2){
	let r = [];
	for (let i=0;i<v1.length;i++){
		r.push(v1[i]+v2[i]);
	}
	return r;
}
function vectSub(v1,v2){
	let r = [];
	for (let i=0;i<v1.length;i++){
		r.push(v1[i]-v2[i]);
	}
	return r;
}

function vdist(v1,v2){
	let d = 0;
	for (let i=0;i<v1.length;i++){
		let diff = v2[i]-v1[i];
		d+=diff*diff;
	}
	return Math.sqrt(d);
}

function swap(v1,gap){
	let result = v1.slice();
	let t = result[gap];
	result[gap]=result[gap+1];
	result[gap+1]=t;
	return result;
}

function invertPerm(p){
	let result=[];
	for (let i=0;i<p.length;i++){
		result.push(p.indexOf(i));
	}
	return result;
}


// let p1 = perms[5];
// let p2 = invertPerm(swap(invertPerm(p1),0));

// let v1 = permToVec(p1)
// let v2 = permToVec(p2)

// console.log("p1")
// console.log(p1)
// console.log(v1)

// console.log("p2")
// console.log(p2)
// console.log(v2)

// console.log("dist = " + vdist(v1,v2));

function getRandomInt(min, max) {
  min = Math.ceil(min);
  max = Math.floor(max);
  return Math.floor(Math.random() * (max - min)) + min;
}

let col1_i = getRandomInt(0,5);
let col2_i = getRandomInt(1,5);

let c1 = col1_i+5;
let c2 = (5)+( (col1_i+col2_i)%5 );
planet_anim = genBigFrames(
	getRandomInt(0,Planet_Eingeweide.length),
	c1,
	c2
	);

// console.log(planet_anim);

	let cw = 80;
	let ch = 24;

	let letterbuffer=[];
	let colorbuffer=[];

	let dimensionen=3;
	let origin=[0,0,0,0];

	let campos=[0,0,-0.5,0];
	let oldcampos = campos;
	
	let camright=[1,0,0,0]
	let camup=[0,-1,0,0];
	let camforward=[0,0,1,0];

	function dot(v1,v2){
		let s = 0;
		for (let i=0;i<v1.length;i++){
			s+=v1[i]*v2[i];
		}
		return s;
	}

	function smul(s,v){
		let k = v.slice();
		for (let i=0;i<k.length;i++){
			k[i]=s*k[i];
		}
		return k;
	}

	function setDimensionen(n){
		dimensionen=n;
		origin=[]
		campos=[]
		camforward=[]
		camup=[]
		camright=[]

		let vecLen=Math.max(dimensionen,3)
		for (let i=0;i<vecLen;i++){
			origin.push(0);
			campos.push(0);

			camforward.push(0);
			camup.push(0);
			camright.push(0);
		}

		if (dimensionen>2){
			campos[2]=-0.5;

			camforward[2]=1;
			camup[1]=1;
			camright[0]=1;

		} else {
			campos[2]=1;

			camforward[2]=-1;
			camup[1]=1;
			camright[0]=1;			
		}
			oldcampos=campos.slice();

	}

	let sterne=[];
	let planeten=[];

	let MAX_DEPTH=1000;

	function dist(p1,p2){
		let s=0;
		for (let i=0;i<dimensionen;i++){
			let diff = p1[i]-p2[i];
			s+=diff*diff;
		}
		s=Math.sqrt(s);
		return s;
	}


	function vectLen(v){
		let d = 0;
		for (let i=0;i<v.length;i++){
			d += v[i] * v[i];
		}
		return Math.sqrt(d);
	}

	//project b onto a
	function project(b,a){
		let d = dot(a,b);
		let amag = vectLen(a);
		return smul(d/(amag*amag),a);
	}

	function normalizedVect(v){
		let l = vectLen(v);
		if (l===0){
			return v;
		}
		let result = v.slice();
		for (let i=0;i<result.length;i++){
			result[i]/=l;
		}
		return result;
	}

	function createBuffer(){
		letterbuffer=[];
		colorbuffer=[];
		depthbuffer=[];

		for (let i=0;i<cw;i++){
			let letter_r = [];
			let color_r = [];
			let depth_r = [];

			for (let j=0;j<ch;j++){
				color_r.push(0);
				letter_r.push(" ");
				depth_r.push(MAX_DEPTH);
			}

			letterbuffer.push(letter_r);
			colorbuffer.push(color_r);
			depthbuffer.push(depth_r);
		}

		sterne=[]

		
		planeten=[];


	}


	function spawnTitelPlaneten(){

		sterne=[];

		planeten=[];
		for (let i=0;i<perms.length;i++)
		{
			// let coord=[];
			// for (let j=0;j<dimensionen;j++){
			// 	coord.push((Math.random()-0.5)*2.0);
			// }
			let normalized = permToVec(perms[i]);
			let col1_i = getRandomInt(0,5);
			let col2_i = getRandomInt(1,5);
			let c1 = col1_i+5;
			let c2 = (5)+( (col1_i+col2_i)%5 );
			let my_planet_anim = genAllFrames(
				getRandomInt(0,Planet_Eingeweide.length),
				c1,
				c2
				);

			let planet = [normalized,my_planet_anim];

			planeten.push(planet);

		}


	}

	function spawnSpielPlaneten(){

		// for (let i=0;i<perms.length;i++)
		{
			let i =2;
			// let coord=[];
			// for (let j=0;j<dimensionen;j++){
			// 	coord.push((Math.random()-0.5)*2.0);
			// }
			let normalized = permToVec(perms[i]);
			let col1_i = getRandomInt(0,5);
			let col2_i = getRandomInt(1,5);
			let c1 = col1_i+5;
			let c2 = (5)+( (col1_i+col2_i)%5 );
			let my_planet_anim = genAllFrames(
				getRandomInt(0,Planet_Eingeweide.length),
				c1,
				c2
				);

			let planet = [normalized,my_planet_anim];

			planeten.push(planet);
		}
	}

	function CoordToScreenSpace(wordpos){
		let cx = Math.round(cw/2);
		let cy = Math.round(ch/2);

		let coord = vectSub(wordpos,campos);
		let sx = dot(coord,camright);
		let sy = dot(coord,camup);
		let d = dot(coord,camforward);


		if(gameState ==="TITEL")
		{
			d=d*10;
		}
			
		sx*=1.8*cx/(2);
		sy*=1.8*cy/(2);


		sx = Math.round(sx);
		sy = Math.round(sy);

		if(gameState==="SPIEL"){
			sy-=3;
		} else if (gameState==="SEQUENZ"){
			sy+=2;
		}
		// sx-=60;

		return [d,[sx,sy]];
	}

	function drawSprite(planet,highlight){

		let cx = Math.floor(cw/2);
		let cy = Math.floor(ch/2);

		let s = CoordToScreenSpace(planet[0]);

		let d = s[0];
		if (dimensionen===2){
			d/=2;
		}
		if (d<0){
			return;
		}
		let sx=s[1][0];
		let sy=s[1][1];

		let mipmaps = planet[1];


		let frame_dat = pickMipMap(mipmaps,d);


		let framew=frame_dat[1];
		let frameh=frame_dat[2];
		let frames=frame_dat[3];

		let frameo_x=-Math.round(framew/2);
		let frameo_y=-Math.round(frameh/2);

		sx+=cx+frameo_x;
		sy+=cy+frameo_y;
		

		if (frames===null){
			return;
		}
			


		// sx-=60;


		let frame = Math.floor(frames.length*time/(3*1000))%frames.length;
		blit(frames[frame],sx,sy,d);

		if (highlight){
			let frame = Math.floor(frames.length*time/(3*1000))%frames.length;
			blit(planet_cursor_highlight,sx-2,sy-1,0);			
		}

	}

	function blit(img,x,y,depth){		
		let text=img[0].split("\n");
		let cols=img[1].split("\n");
		let mask=img[2].split("\n");

		let w =text[0].length;
		let h = text.length;

		if (x>=cw || y>=ch || x+w<=0 || y+h<=0){
			return;
		}
				

		for (let i=0;i<text.length;i++){
			for (let j=0;j<text[i].length;j++){
				if (x+j<0 || y+i<0 || x+j>=cw || y+i>=ch){
					continue;
				}

				if ( mask[i][j] === "." || depthbuffer[x+j][y+i]<depth){
					continue;
				}

				let b = text[i][j];
				let col = cols[i][j];				

				letterbuffer[x+j][y+i]=b;
				colorbuffer[x+j][y+i]=col;
				depthbuffer[x+j][y+i]=depth;
			}
		}
	}

	function clearBuffer(){

		for (let i=0;i<cw;i++){
			for (let j=0;j<ch;j++){
				letterbuffer[i][j]=" ";
				colorbuffer[i][j]=1;
				depthbuffer[i][j]=MAX_DEPTH;
			}
		}
	}

	function onInput(k){
		switch(gameState){
			case "TITEL":
			onTitelInput(k);
			break;
			case "SEQUENZ":
			onSequenzInput(k);
			break;
			case "SPIEL":
			onSpielInput(k);
			break;
		}
	}

	function toggleAudio(){
		audio=!audio;
	}

	function toggleSprache(){
		if (sprache==="DE"){
			sprache="EN";
		} else {
			sprache="DE";
		}
	}

	function onTitelInput(k){

		if (exitanim<exitanimdauer || gameState!=="TITEL"){
			return;
		}

		let menügröße = savegame===null?3:4;
		let audiooption = (menügröße===3 && startcursorIndex===1) || (menügröße===4 && startcursorIndex===2);
		let spracheoption = (menügröße===3 && startcursorIndex===2) || (menügröße===4 && startcursorIndex===3);
		let neuesspiel = startcursorIndex===0;
		let fortsetzen = menügröße===4 && startcursorIndex===1;

		switch(k){
			case 0://u
			if (startcursorIndex>0){
				startcursorIndex--;
			}
			break;
			case 1://d
			if (startcursorIndex+1<menügröße){
				startcursorIndex++;
			}
			break;
			case 2://l
				if (audiooption){
					toggleAudio();
				}
				if (spracheoption){
					toggleSprache();
				}
			break;
			case 3://r
				if (audiooption){
					toggleAudio();
				}
				if (spracheoption){
					toggleSprache();
				}
			break;
			case 4://x
				if (audiooption){
					toggleAudio();
				}
				if (spracheoption){
					toggleSprache();
				}
				if (fortsetzen){
					exitanim=0;
				}
				if (neuesspiel){
					level=0;
					exitanim=0;
				}
			break;
		}

	}

	sequenzen = [
		[
			[//DEU - LEVEL 1
				[
					"SAG",
					"Was ist Zivilisation?",
				],
				[
					"SAG",
					"Sei Zivilisation etwas, was Sinn macht.",
				],
				[
					"SAG",
					"Verstände ich naturlich meine eigene Zivilisation.",
				],
				[
					"WORT",
					"WORT",
				],
				[
					"SAG",
					"Sei meine eigene Zivilisation ein TOR zum größeren Sinn.",
				],
				[
					"SAG",
					"Seien wir losgegangen.",
				]
			],

			[//ENG - LEVEL 1
				[
					"SAG",
					"What is civilization?"
				],
				[
					"SAG",
					"Assume civilization is what makes sense."
				],
				[
					"SAG",
					"Assume my own civilization makes sense to me."
				],
				[
					"WORT",
					"WORT",
				],
				[
					"SAG",
					"Assume that we must leave NOW."
				],
			]
		],



		[
			[//DEU - LEVEL 2
				[
					"SAG",
					"Welcher Level ist es?",
				],
				[
					"SAG",
					"Level 2? Juhu!",
				],
				[
					"SAG",
					"Was ist das wort?",
				],
				[
					"WORT",
					"WORT",
				],
				[
					"SAG",
					"Toll! Los geht's!",
				]
			],

			[//ENG - LEVEL 2
				[
					"SAG",
					"What level is it?"
				],
				[
					"SAG",
					"Level 2? Nice!"
				],
				[
					"SAG",
					"And wot's the word?"
				],
				[
					"WORT",
					"WORT",
				],
				[
					"SAG",
					"Awesome. Let's go!"
				]
			]
		],



		[
			[//DEU - LEVEL 3
				[
					"SAG",
					"Welcher Level ist es?",
				],
				[
					"SAG",
					"Level 3? Juhu!",
				],
				[
					"SAG",
					"Was ist das wort?",
				],
				[
					"WORT",
					"WORT",
				],
				[
					"SAG",
					"Toll! Los geht's!",
				]
			],

			[//ENG - LEVEL 3
				[
					"SAG",
					"What level is it?"
				],
				[
					"SAG",
					"Level 3? Nice!"
				],
				[
					"SAG",
					"And wot's the word?"
				],
				[
					"WORT",
					"WORT",
				],
				[
					"SAG",
					"Awesome. Let's go!"
				]
			]
		],



		[
			[//DEU - LEVEL 4
				[
					"SAG",
					"Welcher Level ist es?",
				],
				[
					"SAG",
					"Level 4? Juhu!",
				],
				[
					"SAG",
					"Was ist das wort?",
				],
				[
					"WORT",
					"WORT",
				],
				[
					"SAG",
					"Toll! Los geht's!",
				]
			],

			[//ENG - LEVEL 4
				[
					"SAG",
					"What level is it?"
				],
				[
					"SAG",
					"Level 4? Nice!"
				],
				[
					"SAG",
					"And wot's the word?"
				],
				[
					"WORT",
					"WORT",
				],
				[
					"SAG",
					"Awesome. Let's go!"
				]
			]
		],



		[
			[//DEU - LEVEL 5
				[
					"SAG",
					"Welcher Level ist es?",
				],
				[
					"SAG",
					"Level 5? Juhu!",
				],
				[
					"SAG",
					"Was ist das wort?",
				],
				[
					"WORT",
					"WORT",
				],
				[
					"SAG",
					"Toll! Los geht's!",
				]
			],

			[//ENG - LEVEL 5
				[
					"SAG",
					"What level is it?"
				],
				[
					"SAG",
					"Level 5? Nice!"
				],
				[
					"SAG",
					"And wot's the word?"
				],
				[
					"WORT",
					"WORT",
				],
				[
					"SAG",
					"Awesome. Let's go!"
				]
			]
		],



		[
			[//DEU - END
				[
					"SAG",
					"Fertig!",
				],
				[
					"SAG",
					"Es gibt nichts mehr zu verstehen.",
				],
				[
					"SAG",
					"Schönen abend noch, innit!",
				]
			],

			[//ENG - END
				[
					"SAG",
					"Done!"
				],
				[
					"SAG",
					"There's nothing more to understand."
				],
				[
					"SAG",
					"Have a lovely even, jo!"
				]
			]
		],


	]


	function onSequenzInput(k){
		if (sequenzEnde<sequenzEndeDauer){
			return;
		}

		switch(k){
			case 0://u
			break;
			case 1://d
			break;
			case 2://l
			break;
			case 3://r
			break;
			case 4://x
			console.log(sichtbareBuchstaben+","+sichtbarerText.length)
			if (sichtbareBuchstaben<sichtbarerText.length){
				sichtbareBuchstaben=sichtbarerText.length;
			} else {
				sequenzSchritt();
			}
			break;
		}

	}

	function onSpielInput(k){

		if (endanim<endanimdauer || wonlevel){			
			if (k===4&&wonlevel){
				flyawayanim=0;
			}
			return;
		}

		// if (bewegunganimation<bewegunganimationdauer){
		// 	return;
		// }
		if (tauschanimation<tauschanimationdauer){
			return;
		}
		oldcampos=campos;
		switch(k){
			case 0://u
			break;
			case 1://d
			break;
			case 2://l
				if (cursorPos>0 && fuelamount>0){
					tauschanimation=tauschanimationdauer;
					lastCursorPos=cursorPos;
					// bewegunganimation=0;
					cursorPos--;	
				}
			break;
			case 3://r
				if (cursorPos<wort.length-2 && fuelamount>0){
					tauschanimation=tauschanimationdauer;
					lastCursorPos=cursorPos;
					// bewegunganimation=0;
					cursorPos++;
				}
			break;
			case 4://x
				if (fuelreward){
					fuelreward=false;
					break;
				}
				if (fuelamount==0){
					break;
				}
				if (words.indexOf(wort)>=0 && fuelamount<fuelcapacity){
					//fuelamount=fuelcapacity;
				} else {
					wort = wort.substring(0,cursorPos)+wort[cursorPos+1]+wort[cursorPos]+wort.substring(cursorPos+2);
					fuelamount--;
					cursorPos_Base=cursorPos;
					tauschanimation=0;
				}
			break;
			case 7://h
				if (outoffuel){
					recovering=true;
					outoffuel=false;
					recoverytimer=0;
				}
			break;
		}
	}

	let keyAllowed = {};

	function onFocus(e){
		keyAllowed = {};
	}

	function onKeyup(e){
		keyAllowed [e.which] = true;
	}

	function checkKey(e) {
	    e = e || window.event;

		if (keyAllowed [e.which] === false) {
			if (e.keyCode == '88' || e.keyCode =='32'||e.keyCode =='13'||e.keyCode =='68'){
				return;
			}
		}
		keyAllowed [e.which] = false;
		 
	    if (e.keyCode == '38') {
	        // up arrow
	    	onInput(0);
	    	e.preventDefault();
	    }
	    else if (e.keyCode == '40') {
	        // down arrow
	    	onInput(1);
	    	e.preventDefault();
	    }
	    else if (e.keyCode == '37') {
	       // left arrow
	    	onInput(2);
	    	e.preventDefault();
	    }
	    else if (e.keyCode == '39') {
	       // right arrow
	    	onInput(3);
	    	e.preventDefault();
	    } else if (e.keyCode == '88' || e.keyCode =='32'||e.keyCode =='13'||e.keyCode =='68'){
	    	onInput(4);
	    	e.preventDefault();
	    } else if (e.keyCode=='90'||e.keyCode=='85'){
	    	onInput(5);
	    } else if (e.keyCode=='27'){
	    	onInput(6);
	    } else if (e.keyCode=='72'){
	    	onInput(7);
	    } else if (e.keycode=='88'){
	    	onInput(8);
	    }

	}

	/**
	 * Returns a random integer between min (inclusive) and max (inclusive).
	 * The value is no lower than min (or the next integer greater than min
	 * if min isn't an integer) and no greater than max (or the next integer
	 * lower than max if max isn't an integer).
	 * Using Math.round() will give you a non-uniform distribution!
	 */
	function getRandomInt(min, max) {
	  min = Math.ceil(min);
	  max = Math.floor(max);
	  return Math.floor(Math.random() * (max - min)) + min;
	}


	function flipBuffer(){

		let text = "";
		let lastcol=-1;

		for (let j=0;j<ch;j++){
			for (let i=0;i<cw;i++){
				let l = letterbuffer[i][j];
				let col = colorbuffer[i][j];
				if (l!==" " &&lastcol!==col){
					if (text.length>0){
						text+="</span>"
					}
					text+=`<span class="col${col}">`
					lastcol=col;
				}
				text+=l;
			}
			if (j<ch-1){
				text+="<br>";
			}
		}
		text+="</span>"

		let textbox = document.getElementById("console");
		textbox.innerHTML=text;
	}

	let sprache="EN";
	function S(de,en){
		if (sprache==="DE"){
			return de;
		} else {
			return en;
		}
	}

	function drawBox(x,y,w,h,c){
		if (w<=0||h<=0){
			return;
		}
		letterbuffer[x][y]="+";
		letterbuffer[x+w-1][y]="+";
		letterbuffer[x][y+h-1]="+";
		letterbuffer[x+w-1][y+h-1]="+";

		colorbuffer[x][y]=c;
		colorbuffer[x+w-1][y]=c;
		colorbuffer[x][y+h-1]=c;
		colorbuffer[x+w-1][y+h-1]=c;

		for (let i=1;i<w-1;i++){
			letterbuffer[x+i][y]="-";
			letterbuffer[x+i][y+h-1]="-";

			colorbuffer[x+i][y]=c;
			colorbuffer[x+i][y+h-1]=c;

			for (let j=1;j<h-1;j++){
				letterbuffer[x+i][y+j]=" ";
			}
		}

		for (let j=1;j<h-1;j++){
			letterbuffer[x][y+j]="|";
			letterbuffer[x+w-1][y+j]="|";

			colorbuffer[x][y+j]=c;
			colorbuffer[x+w-1][y+j]=c;
		}

	}

	let fuelcapacity=4;
	let fuelamount=3;

	function printText(s,x,y,c){
		let origx=x;
		for (let i=0;i<s.length;i++){
			let char = s[i];
			if (char==="\n"){
				y++;
				x=origx-(i+1);
				continue;
			}
			letterbuffer[x+i][y]=char;
			colorbuffer[x+i][y]=c;
		}
	}


	function printRainbowText(s,x,y,length,speed){
		let o = Math.floor(speed*time/1000);
		c = 5+(Math.ceil(o/length)%5);
		for (let i=0;i<s.length;i++){
			letterbuffer[x+i][y]=s[i];
			colorbuffer[x+i][y]=c;
			if ((i+o)%length===0){
				c=c+1;
				if (c===10){
					c=5;
				}
			}
		}
	}

	let startcursorIndex=0;
	let savegame=123;
	let audio=true;

	let exitanimdauer=1.0;
	let exitanim=exitanimdauer;


	let zeigsequenzwort=false;
	let sichtbareBuchstaben=1;
	let sichtbarerText="";
	let sequenzWrapSpalten=30;
	let sichtbarerTextlinien=1;

	function spracheIndex(){		
		return sprache==="DE"?0:1;
	}

	function getStartingWort(){
		let spracheindex = spracheIndex();
		return leveldats[spracheindex][level][0][0]
	}

	function sequenzSchritt(){
		sequenzindex++;

		let spracheindex = spracheIndex();
		if (sequenzindex>=sequenzen[level][spracheindex].length){
			sequenzEnde=0;
			return;
		}

		let entry = sequenzen[level][spracheindex][sequenzindex];
		let action = entry[0];
		let txt = entry[1];
		switch(action){
			case "SAG":
			sichtbareBuchstaben=1;
			sichtbarerText = wordwrap(txt,sequenzWrapSpalten);
			sichtbarerTextlinien =  sichtbarerText.split(/\r\n|\r|\n/).length;
			break;
			case "WORT":
			zeigsequenzwort=true;
			wort=getStartingWort();
			break;
		}

	}

	function wordwrap( long_string, colcount ) {
		let words = long_string.split(" ");
		let result="";
		let curlinelen=0;
		for (let i=0;i<words.length;i++){
			let word=words[i];
			if (word==="\n"){
				continue;
			}
			if (curlinelen+1+word.length > colcount){
				result+="\n";
				curlinelen=0;
			} else {
				if (i>0){
					result+=" ";
					curlinelen++;
				}
			}

			result+=word;
			let nll = word.lastIndexOf("\n");
			if (nll>=0){
				curlinelen=word.length-(nll+1);
			} else {
				curlinelen+=word.length;
			}
		}
	 
		return result;
	}

	function isLetter(c) {
	  return c.toLowerCase() != c.toUpperCase();
	}

	function renderSequenzoberfläche(){

		if (sequenzEnde<sequenzEndeDauer){
			sequenzEnde+=deltatime/1000;



			let pc=1;
			if (sequenzEnde<sequenzEndeDauer){
				pc=sequenzEnde/sequenzEndeDauer;
			}
			
			let tbw = sequenzWrapSpalten+6;
			let tbh = sichtbarerTextlinien+4;
			let oldtbw=tbw;
			let oldtbh=tbh;

			tbw = (Math.floor(tbw*(1-pc*3)));
			tbh = (Math.floor(tbh*(1-pc*3)));
			let tby = 4+Math.floor((oldtbh-tbh)/2);//Math.floor((ch-tbh)/2);
			let tbx = Math.floor((cw-tbw)/2);
			drawBox(tbx,tby,tbw,tbh,8);

			if (sequenzEnde>=sequenzEndeDauer){		

				if (level>=leveldats[spracheIndex()].length){
					level=0;
					setGameState("TITEL");
					return;
				} else {		
					setGameState("SPIEL");
					return;
				}
			}
		} else {

			let tbw = sequenzWrapSpalten+6;
			let tbh = sichtbarerTextlinien+4;
			let tby = 4;//Math.floor((ch-tbh)/2);
			let tbx = Math.floor((cw-tbw)/2);
				//bottom soll 8 sein

			tby=8-tbh+1;

			if (sichtbarerText.length>0){
				drawBox(tbx,tby,tbw,tbh,8);

				printText(sichtbarerText.substring(0,sichtbareBuchstaben),tbx+2,tby+2,8);
			}

			sichtbareBuchstaben++;
			while(sichtbareBuchstaben<sichtbarerText.length && !isLetter(sichtbarerText[sichtbareBuchstaben])){
				sichtbareBuchstaben++;
			}
		}

		if (zeigsequenzwort){

			let bx = 10;
			let by = 17;
			if (wort.length<6){
				bx=15;
			}
			if (wort.length>9){
				bx=5;
			}

			let bw = cw-bx-bx+1;
			let bh = 3;
			drawBox(bx,by,bw,bh,4);

			let tx=  bx+1+1;
			let ty = by+1;
			let tw = bw-2-2;


			let letterDist=2;
			let wortWidth=wort.length+(wort.length-1)*letterDist;
			while (wortWidth<=tw-4 ){
				letterDist+=2;
				wortWidth=wort.length+(wort.length-1)*letterDist;
			}
			
			letterDist-=2;
			wortWidth=wort.length+(wort.length-1)*letterDist;

			let wl = tx+Math.floor((tw-wortWidth)/2);


			let base_cursorX=wl+cursorPos*(letterDist+1)+Math.floor(letterDist/2);
			let cursorX=base_cursorX;


			let wortCol = 8;

			for (let i=0;i<wort.length;i++)
			{
				if (tauschanimation<tauschanimationdauer){
					if (i===cursorPos||i===cursorPos+1){
						continue;
					}
				}
				letterbuffer[wl+i*(letterDist+1)][ty]=wort[i];
				colorbuffer[wl+i*(letterDist+1)][ty]=wortCol;		
			}
		}
	}


	function renderTiteloberfläche(){

		let topmargin=4;

		let part2 = exitanim<exitanimdauer && exitanim*2>=exitanimdauer;
		if (part2){
			let p = Math.floor(2*(exitanim/exitanimdauer-0.5)*(ch));
			topmargin+=p;
		}
		let paddingx=4;
		let paddingy=1;
		let titel = S("Entdeckungsreise!","Voyage of discovery!");

		let bw = 18+2+4+2;//titel.length+2*paddingx+2;
		let bh = 1+paddingy*2+2;

		let zx = cw/2;
		let zy = cw/2;

		let tb_x = Math.floor(zx-bw/2);
		let tb_y = topmargin+1;

		drawBox(tb_x,tb_y,bw,bh,4);
		// printRainbowText(titel,tb_x+1+paddingx,tb_y+1+paddingy,4,20)
		printText(titel,tb_x+Math.floor((bw-titel.length)/2),tb_y+1+paddingy,8)

		//optionen
		//new game
		//continue game (wo möglich)
		//sprache
		let optionenzahl=savegame===null?3:4;

		let optionen = [
			S("Spiel starten","Start Game"),
			S("Spiel fortsetzen	","Resume Game"),
			audio 
				? S("Audio : ein","Audio : on")
				: S("Audio : aus","Audio : off"),
			S("Sprache : Deutsch","Language : English")
		]
		if (optionenzahl===3){
			optionen.splice(1,1);
		}

		let menü_padding_y=0;

		let menü_w=18+2+4;
		let menü_h=optionen.length+4;
		
		let menü_x = Math.floor(zx-menü_w/2);
		let menü_y = tb_y+bh-1+menü_padding_y;

		drawBox(menü_x-1,menü_y,menü_w+2,menü_h,4);
		for (let i=0;i<optionen.length;i++){
			let tx = menü_x+1+2;
			let ty = menü_y+2+i;
			let t = optionen[i];
			if (startcursorIndex===i){
				if (exitanim<exitanimdauer){
					printRainbowText(t,tx,ty,2,30)

					let rots = ["|","/","-","\\"];
					let frame = Math.floor(rots.length*time/(0.5*1000))%rots.length;

					let char = rots[frame];
					letterbuffer[tx-2][ty]=char;
					colorbuffer[tx-2][ty]=8;
					letterbuffer[tx-1+menü_w-4][ty]=char;
					colorbuffer[tx-1+menü_w-4][ty]=8;

				} else {
					printText(t,tx,ty,8)
					letterbuffer[tx-2][ty]="[";
					colorbuffer[tx-2][ty]=8;
					letterbuffer[tx-1+menü_w-4][ty]="]";
					colorbuffer[tx-1+menü_w-4][ty]=8;
				}
			} else {
				if (exitanim>=exitanimdauer){
					printText(t,tx,ty,6)
				} else {
					printText(t,tx,ty,4)					
				}
			}
		}



	}

	function centerString(s,w){
		var l = s.length;
		var lpadding = Math.floor((w-s.length)/2);
		var rpadding = w-(s.length+lpadding);
		return s.padStart(l+lpadding," ").padEnd(w," ");
	}

	let entdeckungmax=4;
	let entdeckung=2;

	let recovering=false;
	let outoffuel=false;
	function renderSpieloberfläche(){

		let fuelkisteheight=2+fuelcapacity;

		let fuelkistetop=1;//fuelkistebottom-fuelkisteheight+1;
		let fuelkistebottom = fuelkistetop+fuelkisteheight-1;

		//offset anim
		let segmentheight=Math.max(fuelkistebottom,2+entdeckungmax);
		//should go from -segmentheight to 0
		let frameprogress=segmentheight-Math.min(spielticker,segmentheight);

		//fuel
		drawBox(0,fuelkistetop-frameprogress,3,fuelkisteheight,0);
		printText(S("Treibstoff","fuel"),0,0-frameprogress,3)

		for (let i=0;i<fuelamount;i++){
			let ypos= fuelkistebottom-1-i;
			ypos-=frameprogress;
			if (ypos>0){
				letterbuffer[1][ypos]="=";
				colorbuffer[1][ypos]=9;
			}
		}

		//discovery


		let entdeckungkistebottom = ch-2;
		let entdeckungkisteheight=2+entdeckungmax;

		let entdeckungkistetop=entdeckungkistebottom-entdeckungkisteheight+1;



		let dbox_w=wort.length+2;
		let dbox_h=entdeckungmax+2;
		let dbox_x=cw-1-dbox_w;
		let dbox_y=1;
		drawBox(dbox_x,dbox_y-frameprogress,dbox_w,dbox_h,5);

		for (let i=0;i<entdeckung;i++){
			let w = visitedlist[i];
			let d_col = w===wort?10:2;
			printText(w,dbox_x+1,dbox_y+1+i-frameprogress,d_col)
		}

		var dtext = S("Entdeckung","discovery")
		printText(dtext,cw-dtext.length-1,0-frameprogress,3)


		if (wonlevel){

			let hbox_y=0;
			let hbox_w=40;
			let hbox_h=5;
			let hbox_x=Math.floor((cw-hbox_w)/2);

			drawBox(
					hbox_x,hbox_y,
					hbox_w,hbox_h,
					7);

			printText(
					centerString(
						S("Alles entdeckt!","Everything discovered!"),
						hbox_w-2
					),
					hbox_x+1,
					hbox_y+1,
					1
				);

			if (flyawayanim>=flyawayanimdauer){
				printText(
						centerString(
							S("Drucken Sie x um weiter zu fahren","Press X to continue"),
							hbox_w-2
						),
						hbox_x+1,
						hbox_y+3,
						1
					);
			}
			
		}

		if (fuelreward)
		{			

			let hbox_y=0;
			let hbox_w=40;
			let hbox_h=7;
			let hbox_x=Math.floor((cw-hbox_w)/2);

			drawBox(
					hbox_x,hbox_y,
					hbox_w,hbox_h,
					8);

			printText(
					centerString(
						S("Treibstofftankupgrade","Fuel Tank Upgrade"),
						hbox_w-2
					),
					hbox_x+1,
					hbox_y+1,
					8
				);
			
			printText(
					wordwrap(
						S(
							`Die Kapazität Ihres Treibstofftank wurde von ${cap_pre} auf ${cap_post} erhöhrt!`,
							`Your tank capacity has been increased from ${cap_pre} to ${cap_post}!`
						),
						hbox_w-2
					),
					hbox_x+1,
					hbox_y+2,
					8
				);


			printText(
					centerString(
						S("Drucken Sie x um weiter zu fahren","Press X to continue"),
						hbox_w-2
					),
					hbox_x+1,
					hbox_y+hbox_h-2,
					1
				);
		}

		if (outoffuel)
		{
			
			let zeichen_w=getStrW(keintreibstoff_zeichen[0]);
			let zeichen_h=getStrH(keintreibstoff_zeichen[0]);
			let zeichen_x=Math.floor((cw-zeichen_w)/2);
			let zeichen_y=1;

			blit(keintreibstoff_zeichen,zeichen_x,zeichen_y,0);


			let hbox_y=zeichen_h+1;
			let hbox_w=40;
			let hbox_h=4;
			let hbox_x=Math.floor((cw-hbox_w)/2);

			drawBox(
					hbox_x,hbox_y,
					hbox_w,hbox_h,
					7);

			printText(
					centerString(
						S("Treibstoff ausgegangen!","Out of fuel!"),
						hbox_w-2
					),
					hbox_x+1,
					hbox_y+1,
					1
				);
			
			printText(
					centerString(
						S("Drucken Sie H, um hilfen zu bitten","Press H to call for help"),
						hbox_w-2
					),
					hbox_x+1,
					hbox_y+2,
					1
				);
		}



		if (words.indexOf(wort)>=0&&fuelamount<fuelcapacity && tauschanimation>=tauschanimationdauer)
		{
					
			let hbox_y=-1;
			let hbox_w=40;
			let hbox_h=3;
			let hbox_x=Math.floor((cw-hbox_w)/2);

			// drawBox(
			// 		hbox_x,hbox_y,
			// 		hbox_w,hbox_h,
			// 		0);

			printText(
					centerString(
						S("Auftanken...","Refueling"),
						hbox_w-2,

					),
					hbox_x+1,
					hbox_y+1,
					9
				);
			
		}


		let bx = 10;
		let by = 17-Math.min(spielticker,3);
		if (wort.length<6){
			bx=15;
		}
		if (wort.length>9){
			bx=5;
		}

		let bw = cw-bx-bx+1;
		let bh = 3;

		printText(S("Kompass","compass"),bx+1,by+3,3)

		let tx=  bx+1+1;
		let ty = by+1;
		let tw = bw-2-2;


		let letterDist=2;
		let wortWidth=wort.length+(wort.length-1)*letterDist;
		while (wortWidth<=tw-4 ){
			letterDist+=2;
			wortWidth=wort.length+(wort.length-1)*letterDist;
		}
		
		letterDist-=2;
		wortWidth=wort.length+(wort.length-1)*letterDist;

		let wl = tx+Math.floor((tw-wortWidth)/2);


		let base_cursorX=wl+cursorPos*(letterDist+1)+Math.floor(letterDist/2);
		let cursorX=base_cursorX;

		let raumschiffbild_index=0;
		let schiff_offset=0;
		// if (bewegunganimation<bewegunganimationdauer){
		// 	let pc = bewegunganimation/bewegunganimationdauer;
		// 	raumschiffbild_index= 1+Math.floor(pc*3);
		// 	// pc = raumschiffbild_index/5;
		// 	if (lastCursorPos>cursorPos){
		// 		raumschiffbild_index=4-raumschiffbild_index;
		// 		schiff_offset=1+Math.floor((letterDist-1)*(1-pc));
		// 		cursorX+=schiff_offset;
		// 	} else {
		// 		schiff_offset=1+Math.floor((letterDist)*(pc-1))-1;
		// 		cursorX+=schiff_offset;
		// 	}
		// } 

		let wortCol = (words.indexOf(wort)>=0) ? 8 :6;
		if (wortCol===8){
			lastgoodword=wort;
		}

		if (tauschanimation<tauschanimationdauer){
			wortCol=6;
			let pc = tauschanimation/tauschanimationdauer;
		 	raumschiffbild_index= 1+Math.floor(pc*3);
			if (lastCursorPos>cursorPos){
				raumschiffbild_index=4-raumschiffbild_index;
			} else {
			}
		} 
		if (endanim<endanimdauer){
			drawBox(bx,by,bw,bh,8);
		} else {
			drawBox(bx,by,bw,bh,4);			
		}

		if (wortCol===8){
			if (fuelamount<fuelcapacity){
				fuelamount++;
			}
		}

		if (wonlevel===false){
			letterbuffer[cursorX][ty]="&lt;";// ↔︎⟳
			colorbuffer[cursorX][ty]=6;		
			letterbuffer[cursorX+1][ty]="&gt;";
			colorbuffer[cursorX+1][ty]=6;	
		}


		for (let i=0;i<wort.length;i++)
		{
			if (tauschanimation<tauschanimationdauer){
				if (i===cursorPos||i===cursorPos+1){
					continue;
				}
			}
			letterbuffer[wl+i*(letterDist+1)][ty]=wort[i];
			colorbuffer[wl+i*(letterDist+1)][ty]=wortCol;		
		}

		if (tauschanimation<tauschanimationdauer){
			let pc = tauschanimation/tauschanimationdauer;
			let x1 = wl+cursorPos*(letterDist+1);
			let x2 = wl+(cursorPos+1)*(letterDist+1);
			let y = ty;
			let mx = (x2+x1)/2;
			let r = x2-mx;
			//pc=0 -> 0 grad
			//pc=1 -> 180 grad

			let dx1 = -r*Math.cos(-pc*Math.PI);
			let dy1 = -r*Math.sin(-pc*Math.PI);

			let dx2 = -r*Math.cos(-(1+pc)*Math.PI);
			let dy2 = -r*Math.sin(-(1+pc)*Math.PI)/2;

			if (dy1>1){
				dy1=1;
			}
			if (dy2<-1){
				dy2=-1;
			}

			let nx1 = Math.round(mx+dx1);
			let ny1 = Math.round(ty+dy1);

			let nx2 = Math.round(mx+dx2);
			let ny2 = Math.round(ty+dy2);

			letterbuffer[nx1][ny1]=wort[cursorPos+1];
			colorbuffer[nx1][ny1]=6;
			letterbuffer[nx2][ny2]=wort[cursorPos];
			colorbuffer[nx2][ny2]=6;
		}


		// letterbuffer[cursorX+2][ty]=">";
		// colorbuffer[cursorX+2][ty]=6;		

		// let raumschiffbild_index=1;

		// let raumschiffbild_index = Math.floor(raumschiff_bilder.length*time/(1*1000))%raumschiff_bilder.length;


		// if (cursorPos<cursorPos_Base){
		// 	raumschiffbild_index=0;
		// } else if (cursorPos>cursorPos_Base){
		// 	raumschiffbild_index=2;
		// }
		if (fuelamount===0){
			raumschiffbild_index=4;
		}

		let raumschiffbild=raumschiff_bilder[raumschiffbild_index]


		if (flyawayanim<flyawayanimdauer){
			let from_x = base_cursorX+raumschiffbild[0]+schiff_offset;
			let from_y = ty+2;

			let to_x = from_x;
			let to_y = 0-2*getStrH(raumschiffbild[1][0]);



			let pc = flyawayanim/flyawayanimdauer;

			raumschiffbild_index = 0;// Math.floor(pc*20)%4;
			raumschiffbild=raumschiff_bilder[raumschiffbild_index]

			pc=Math.pow(pc,1.5);
			
			
			var cur_x=from_x;
			var cur_y = Math.floor((1-pc)*from_y+pc*to_y);

			blit(raumschiffbild[1],cur_x,cur_y,-10);

		} else if (recovering===false){
			blit(raumschiffbild[1],base_cursorX+raumschiffbild[0]+schiff_offset,ty+2,-1);
		}

		let letterspacing=Math.floor(tw/wort.length)-1;
		let zentrum = cw;


		if (recovering===true)
		{


			let hbox_y=3;
			let hbox_w=cw-5;
			let hbox_h=ch-5;
			let hbox_x=3;

			drawBox(
					hbox_x,hbox_y,
					hbox_w,hbox_h,
					7);

			let abschleppwagen_w=getStrW(abschleppwagen[0]);
			let abschleppwagen_h=getStrH(abschleppwagen[0]);
			let abschleppwagen_x=Math.floor((cw-abschleppwagen_w)/2);
			let abschleppwagen_y=Math.floor((ch-abschleppwagen_h)/2)-2;

			blit(abschleppwagen,abschleppwagen_x,abschleppwagen_y,-1);

			let text_y=abschleppwagen_y+abschleppwagen_h+1;

			printText(
					centerString(
						S("Rückführung des Fahrzeuges im Gange","Recovering vehicle"),
						hbox_w-2
					),
					hbox_x+1,
					text_y
				);
			
			let dotx = Math.floor((cw-recoverymax)/2)
			printText(
					"".padStart(recoverytimer,".").padEnd(recoverymax," "),
					dotx,
					text_y+2
				);

		}
	}


	function render(){
		clearBuffer();

		let cx = Math.floor(cw/2);
		let cy = Math.floor(ch/2);


		// let frame = Math.floor(planet_anim.length*time/(3*1000))%planet_anim.length;
		// blit(planet_anim[frame],cx-4,cy-4,1);

		let selectionIndex=words.indexOf(wort);
		for (let i=0;i<planeten.length;i++){	
			let planet = planeten[i];
			let highlight = gameState ==="SPIEL" && selectionIndex===i && tauschanimation>=tauschanimationdauer;
			drawSprite(planet,highlight);
		}

		for (let i=0;i<sterne.length;i++){			
			let coord = sterne[i];
				
			let s = CoordToScreenSpace(coord);

			let d = s[0];
			let sx=s[1][0];
			let sy=s[1][1];

			sx+=cx;
			sy+=cy;
			if (gameState==="SEQUENZ"){
				// sx=cx+Math.floor(sx/2);
				// sy=cy+Math.floor(sy/2);
				d*=2;
			}			
			if (sx>=cw || sy>=ch || sx<0 || sy<0){
				continue;
			}

			if (d<depthbuffer[sx][sy]){
				if (gameState==="SPIEL"){
					letterbuffer[sx][sy]=".";
				} else {
					if (d>1.2){			
						letterbuffer[sx][sy]=".";
					} else if (d>0.8){
						letterbuffer[sx][sy]="o";
					} else {
						letterbuffer[sx][sy]="O";				
					}
				}
				let col;
				if (d>1.5){
					col=3;
				} else if (d>0.2){
					col=3;
				} else {
					col=2;
				}
				colorbuffer[sx][sy]=col;
				depthbuffer[sx][sy]=d;
			}
		}

		switch(gameState){
			case "TITEL":
				renderTiteloberfläche();
				break;
			case "SEQUENZ":
				renderSequenzoberfläche();
				break;
			case "SPIEL":
				renderSpieloberfläche();
				break;
		}

		flipBuffer();
	}

	let targetstate="";
	function setGameState(newgs){
		targetstate=newgs;
	}

	function startTitleBildschirm(){
		words = titelwords;
		setDimensionen(words[0].length-1);
		generateWordPerms();

		
		spawnTitelPlaneten();

		
		render();
	}

	function rot(p,i_axis,j_axis,theta){
		if (j_axis>=dimensionen){
			j_axis=dimensionen-1;
		}
		let pi = p[i_axis];
		let pj = p[j_axis];
		let ct = Math.cos(theta);
		let st = Math.sin(theta);

		p[i_axis] = pi*ct-pj*st;
		p[j_axis] = pi*st+pj*ct;
	}

	let time=0;

	let tauschanimationdauer=0.6;
	let tauschanimation=tauschanimationdauer;

	let bewegunganimationdauer=0.5;
	let bewegunganimation=bewegunganimationdauer;


	function titelTick(){
		if (exitanim<exitanimdauer){
			exitanim+=deltatime/1000;
			if (exitanim>=exitanimdauer){
				setGameState("SEQUENZ");
			}
		}


		let theta = 2*Math.PI*deltatime/(12*1000);

		

		for (let i=0;i<sterne.length;i++){
			let s = sterne[i];
			if (tauschanimation<tauschanimationdauer){
				for (let j=0;j<dimensionen;j++){
					rot(s,j,2,-3*theta/(j+1));
				}
			}
		}

		if (exitanim<exitanimdauer)
		{
			campos[2]-=3*theta;
		} else {

			for (let i=0;i<planeten.length;i++){
				let planet = planeten[i];

				if (dimensionen>2)
				{
					for (let j=0;j<dimensionen;j++){
						if (j===2){
							continue;
						}
						rot(planet[0],j,2,-theta/(j+1));
					}
				} else {
					rot(planet[0],0,1,-theta);
				}
			}
		}
	}


	let lastgoodword="";
	let recoverytimer=0;
	let recoverymax=30;

	let wonlevel=false;

	let endanimdauer=0.3;
	let endanim=endanimdauer;

	let flyawayanimdauer=1.5;
	let flyawayanim=flyawayanimdauer;

	function startEnd(){
		endanim=0;
	}

	let fuelreward=0;
	let cap_pre=0;
	let cap_post=0;

	function doGiveReward(am){
		cap_pre = fuelcapacity;
		fuelcapacity+=am;
		cap_post = fuelcapacity; 
		fuelreward=true;
	}

	let spielticker=0;

	function spielTick(){
		spielticker++;
		if (flyawayanim<flyawayanimdauer){
			flyawayanim+=deltatime/1000;
			if (flyawayanim>=flyawayanimdauer){
				level++;
				setGameState("SEQUENZ");
			}
		}

		if (recovering){
			recoverytimer+=2;
			if (recoverytimer>recoverymax){
				recovering=false;
				// outoffuel=false;
				wort = lastgoodword;				
			}
		}

		if (endanim<endanimdauer){
			endanim+=deltatime/1000;
			if (endanim>=endanimdauer){
				wonlevel=true;
			}
		}

		if (tauschanimation<tauschanimationdauer){
			tauschanimation+=deltatime/1000;
			if (tauschanimation>=tauschanimationdauer){
				if (fuelamount===0 && words.indexOf(wort)===-1){
					outoffuel=true;
				}
				if (words.indexOf(wort)>=0 && visitedlist.indexOf(wort)===-1){
					visitedlist.push(wort);
					if (rewards[wort]>0){
						doGiveReward(rewards[wort]);
					}
					entdeckung++;
					if (entdeckung===entdeckungmax){
						startEnd();
					}
				}
			}
		}

		bewegunganimation+=deltatime/1000;

		let theta = 2*Math.PI*deltatime/(12*1000);
		for (let i=0;i<sterne.length;i++){
			let s = sterne[i];
			if (tauschanimation<tauschanimationdauer){
				for (let j=0;j<dimensionen;j++){
					// rot(s,j,2,-3*theta/(j+1));
				}
			}
		}

		for (let i=0;i<planeten.length;i++){
			let planet = planeten[i];
			if (tauschanimation<tauschanimationdauer){
				for (let j=0;j<dimensionen;j++){
					// rot(planet[0],j,2,-5*theta/(j+1));
				}
			}
			if (dimensionen>2)
			{
				for (let j=0;j<dimensionen;j++){
					if (j===2){
						continue;
					}
					// rot(planet[0],j,2,-theta/(j+1));
				}
			} else {
				// rot(planet[0],0,1,-theta);
			}
		}
		setGameCamPos(false);


	}

	function sequenzTick(){
		let theta = 2*Math.PI*deltatime/(12*1000);
		for (let i=0;i<sterne.length;i++){
			let s = sterne[i];
			rot(s,0,2,-0.15*theta);
		}

	}

	function tick(){
		time+=deltatime;

		switch (gameState){
			case "TITEL":
				titelTick();
				break;
			case "SEQUENZ":
				sequenzTick();
				break;
			case "SPIEL":
				spielTick();
				break;
		}

		render();

		if (targetstate!==""){
			gameState=targetstate;
			targetstate="";
			switch(gameState){
				case "TITEL":
					startTitleBildschirm();
				break;
				case "SEQUENZ":
					startSequenz();
					break;
				case "SPIEL":
					startSpiel();
					break;
				break;
			}
			tick();
		}
	}

	let sequenzindex=0;
	let sequenzEndeDauer=1.0;
	let sequenzEnde=0;

	function startSequenz(){
		sequenzEnde=sequenzEndeDauer;
		sichtbarerText="";
		sichtbareBuchstaben=0;
		zeigsequenzwort=false;
		setDimensionen(3)


		planeten=[];

		let my_planet_anim = genAllFrames(
				0,
				5,//blue
				6//green
				);
		let planetframes = [my_planet_anim[7]];
		planetframes[0][0]=100;
		let planet = [ origin.slice(), planetframes];
		planeten.push(planet);

		sterne=[];

		while(sterne.length<15){
			let stern = [];
			for (let j=0;j<dimensionen;j++){
				stern.push((Math.random()-0.5)*1.0);
			}
			let d = dist(stern,origin);
			if (d>0.5 && d<1.0)
			{
				sterne.push(stern);
			}
		}

		
		sequenzindex=-1;
		sequenzSchritt();		
	}

	function setGameCamPos(reset_cam_dir){
		let wortindex = words.indexOf(wort);
		let wordpos = permToVec(wordToPerm(baseword, wort));
		let camDist=1;
		let wordpos_len = vectLen(wordpos);

		let camback = normalizedVect(wordpos);

		let reset_cam_pos = tauschanimation>=tauschanimationdauer;
		// reset_cam_pos=true;		
		// reset_cam_dirt=true;

		// jumpcampos=true;
		let targetcampos = smul(wordpos_len+camDist,camback);	
		
		if (dimensionen===2){
			targetcampos=vectAdd(wordpos,[0,0,-1]);
		}

		// reset_cam_pos=true;
		// reset_cam_dir=true;

		if (reset_cam_pos){
			campos=targetcampos;
			// oldcampos=campos;
		} else {

			let pc = tauschanimation/tauschanimationdauer;
			campos = vectLerp(oldcampos,targetcampos,pc);	

			campos_l = vectLen(campos);
			oldcampos_l = vectLen(oldcampos);	
			targetcampos_l = vectLen(targetcampos);	
			let m = Math.min(oldcampos_l,targetcampos_l);
			let current_l  = (1-pc)*oldcampos_l+pc*targetcampos_l;
			campos = smul(current_l/campos_l,campos);

		}
			

		camforward = smul(-1,campos)

		if (reset_cam_dir){
			//camup, normal to camforward
			//https://math.stackexchange.com/questions/133177/finding-a-unit-vector-perpendicular-to-another-vector
			camup = origin.slice();
			let n =0;
			let m = 0;
			for (m=0;m<camup.length;m++){
				if (Math.abs(camforward[m])>0.001){
					n=0;
					if (m===0){
						n=1;
					}
					camup[n]=camforward[m];
					camup[m]=-camforward[n];
					break;
				}
			}
			camup = normalizedVect(camup);

			if (dimensionen>=3){
				let o=0;
				for(o=0;o<3;o++){
					if (o===m||o===n){
						//boo
					} else {
						break;
					}
				}
				//get the cross product in indices o, m, and n?
				if (dimensionen>2)
				{
					camright=highercross(camup,camforward,o,m,n);
				} else {
					camright=camup;
				}
			} else {
				camright=camforward;
			}
		} else 
		{
			//camup and cam right

			let preup = camup;
			

			let camup_residue = project(camup,camforward);
			camup = vectSub(camup,camup_residue);
			camup = normalizedVect(camup);


			
			let postup = camup;
			
			if (dimensionen>2){
				let camright_residue1 = project(camright,camforward);
				camright = vectSub(camright,camright_residue1);
				camright = normalizedVect(camright);

				let camright_residue2 = project(camright,camup);
				camright = vectSub(camright,camright_residue2);
				camright = normalizedVect(camright);
			} else {
				camright=camforward;
			}

		}

		if (dimensionen===2){
			camforward=[0,0,1];
			camright=[1,0,0];
			camup=[0,1,0];
		}
		// targetcampos = vectAdd(targetcampos,smul(0.2,camup));


		//camright

	} 

	function highercross(a,b,i1,i2,i3){
		let o = origin.slice();
		o[i1]=a[i2]*b[i3]-a[i3]*b[i2];
		o[i2]=a[i3]*b[i1]-a[i1]*b[i3];
		o[i3]=a[i1]*b[i2]-a[i2]*b[i1];
		return o;
	}

	function wordToPerm(grundwort,w){
		let p = [];
		for (let i=0;i<grundwort.length;i++){
			p.push(i);
		}

		for (let i=0;i<grundwort.length;i++){
			let c = grundwort[i];
			let cindex = w.indexOf(c);
			p[i] = cindex;
		}
		return p;
	}




	function wordToRPerm(grundwort,w){
		let p = [];
		for (let i=0;i<grundwort.length;i++){
			p.push(i);
		}

		for (let i=0;i<grundwort.length;i++){
			let c = grundwort[i];
			let cindex = w.indexOf(c);
			p[cindex] = i;
		}
		return p;
	}
	
	function startSpiel(){
		spielticker=0;

		if (level===0){
			startcursorIndex=1;
		} else {
			startcursorIndex=0;
		}


		sterne=[]

		wonlevel=false;
		recovering=false;
		outoffuel=false;
		endanim=endanimdauer;			

		let spracheindex = spracheIndex();

		//load level dat

		let curleveldat = leveldats[spracheindex][level];

		entdeckungmax = curleveldat.length;
		entdeckung=1;

		words=[];
		rewards={};
		visitedlist=[];

		for (var i=0;i<curleveldat.length;i++){
			var cld=curleveldat[i];
			var w = cld[0];
			var r = cld[1];
			words.push(w);
			rewards[w]=r;
		}
		wort=words[0];

		console.log(wort)
		console.log(rewards)
		fuelcapacity=rewards[wort];
		console.log("WORD "+wort+"\tREWARD "+fuelcapacity);
		fuelamount=0;

		visitedlist.push(wort);

		baseword = wort;

		generateWordPerms();
		
		setDimensionen(words[0].length-1)
		spawnTitelPlaneten();

		sterne=[]
		while(sterne.length<15){
			let stern = [];
			for (let j=0;j<dimensionen;j++){
				stern.push((Math.random()-0.5)*2.0);
			}
			let d = dist(stern,origin);
			// if (d>0.5 && d<1.0)
			{
				sterne.push(stern);
			}
		}

		// sterne=[origin]

		setGameCamPos(true);
	}

	let deltatime=100;

	function globalSetup(){
		setDimensionen(words[0].length-1)

		setInterval(tick, deltatime);

		document.onkeydown = checkKey;	
		document.onkeyup = onKeyup;	
		document.onfocus = onFocus;	

		createBuffer();		

		// setGameState("SPIEL")
		setGameState("TITEL")
		// setGameState("SEQUENZ");

		handleresize();
	}

	window.onload =globalSetup;
	window.onresize = handleresize;
</script>
</body>
</html>